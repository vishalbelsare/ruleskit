<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ruleskit.activation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.activation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
from typing import Union, List
import numpy as np
import ast
import sys
import random
from time import time
from bitarray import bitarray
from tempfile import gettempdir
from pathlib import Path
from .logger.logger import log as logger

MAX_INT_32 = 2 ** 32


class Activation(ABC):

    DTYPE = str
    FORCE_STAT = False
    WILL_COMPARE = False
    DEFAULT_TEMPDIR = Path(gettempdir())

    @classmethod
    def clean_files(cls):
        for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
            path.unlink()

    def __init__(
        self,
        activation: Union[np.ndarray, bitarray, str, int] = None,
        optimize: bool = True,
        length: int = None,
        to_file: bool = False,
    ):
        &#34;&#34;&#34;Compresses an activation vector into a str(list) describing its variations or an bitarray of booleans

        stored data will be either a str(list):
            Compression is done : First element of the list is the first value of the array last element of the list is
            the length of the array The other elemnts are the coordinates that changed values
        or a np.ndarray:
            same as str(list) but the list is casted into np.array instead of str
        or an bitarray:
            The input vector [1 0 0 1 0 0 0 1 1...] where each entry uses up one bit of memory
        or an integer
            taking the input vector [1 0 0 1 0 0 0 1 1...], converts it to binary string representation :
            &#34;100100011...&#34; then cast it into int using int(s, 2). This is done if Activation.WILL_COMPARE is True :
            converting to int is slower than to bit array, but comparing ints is faster. Size is equivalent to bitarray.
        or in a file stored locally.
            This is done if name_for_file is not None

        The method will choose how to store the data based on the size (in MB) of the compressed list : if it is
        superior than in bitarray/int, it will take less memory and is prefered. If compression is used and
        dtype is np.ndarray, will check that numbers present in the compressed vector can be stored as int32 to gain
        memory. Else, uses int64.

        Parameters
        ----------
        activation: Union[np.ndarray, bitarray, str, int]
            If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
            If str : compressed vector
            If bitarray : same as np.array but takes 64x less memory (each entry is stored in one bit only)
            If int : as an integer
        optimize: bool
            Only relevent &#39;value&#39; is an bitarray or integer. In that case, will check whether using compression saves up
            memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy is
            computed.
        length: int
            Only valid if &#39;value&#39; is an integer. An activation vector stored as an integer has lost the information
            about its size : [0 0 0 1 0 0 0 1 1...] to nit gives 100011... which in turn gives back [1 0 0 0 1 1...].
            To get the leading zeros back, one must specify the length of the activation vector.
        to_file: bool
            If True, then activation vector is stored in a file in
            Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt (default value = False)
        &#34;&#34;&#34;
        self.optimize = optimize
        self.length = None  # Will be set by init methods
        self._entropy = None  # Will be set if activation is not an integer or if optimize is True
        self.data_format = None  # Will be set by init methods
        self.data = None  # Will be set by init methods
        self._rel_entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._nones = None  # Will be set if activation is not an integer or if optimize is True
        self._coverage = None
        self._time_write = -1
        self._time_read = -1
        self._time_compressed_to_raw = -1
        self._time_raw_to_compressed = -1
        self._time_raw_to_integer = -1
        self._time_bitarray_to_raw = -1
        self._time_raw_to_bitarray = -1
        self._time_compressed_to_bitarray = -1
        self._time_bitarray_to_compressed = -1
        self._time_integer_to_compressed = -1
        self._time_integer_to_raw = -1
        self._n_written = 0
        self._n_read = 0
        self._n_compressed_to_raw = 0
        self._n_raw_to_compressed = 0
        self._n_bitarray_to_raw = 0
        self._n_integer_to_raw = 0
        self._n_raw_to_bitarray = 0
        self._n_raw_to_integer = 0
        self._n_bitarray_to_compressed = 0
        self._n_integer_to_compressed = 0
        self._n_compressed_to_bitarray = 0
        self._n_compressed_to_integer = 0
        self._sizeof_compressed_array = -1
        self._sizeof_compressed_str = -1
        self._sizeof_bitarray = -1
        self._sizeof_integer = -1
        self._sizeof_raw = -1
        self._sizeof_file = -1
        self._sizeof_path = -1

        if isinstance(activation, str) and &#34;,&#34; not in activation:
            if Activation.WILL_COMPARE:
                activation = int(activation, 2)
            else:
                activation = bitarray(activation)

        if isinstance(activation, bitarray):
            self._init_with_bitarray(activation, Activation.DTYPE, optimize)

        elif isinstance(activation, int):
            self._init_with_integer(activation, Activation.DTYPE, length, optimize)

        elif isinstance(activation, str):
            self._init_with_str(activation)

        elif isinstance(activation, np.ndarray):
            if activation[-1] &gt; 1:
                self._init_with_compressed_array(activation)
            else:
                if to_file:
                    if not self._write(activation):
                        self._init_with_raw(activation, Activation.DTYPE)
                else:
                    self._init_with_raw(activation, Activation.DTYPE)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )

    def __copy__(self):
        if self.data_format == &#34;integer&#34;:
            return Activation(self.raw, optimize=self.optimize, length=self.length)
        return Activation(self.raw, optimize=self.optimize, to_file=self.data_format == &#34;file&#34;)

    # def __del__(self):
    #     if hasattr(self, &#34;data&#34;) and hasattr(self, &#34;data_format&#34;) and self.data_format == &#34;file&#34;:
    #         if self.data.is_file():
    #             self.data.unlink()

    def delete(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            if self.data.is_file():
                self.data.unlink()
        else:
            del self.data
            self.data = None

    def _write(self, value: np.ndarray):

        logger.debug(f&#34;Activation vector is raw, store it in a file&#34;)
        self._sizeof_raw = sys.getsizeof(value) / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        arange = (0, int(1e64))
        number = random.randint(*arange)
        data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        attempts = 0
        while data.is_file():
            if attempts &gt; 99:
                logger.warning(&#34;Failed to save activation vector locally after 100 attempts at finding an available&#34;
                               &#34; name. Will keep it in RAM.&#34;)
                return False
            number += 1
            attempts += 1
            data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        data.touch()
        self.data = data
        self.data_format = &#34;file&#34;
        with open(self.data, &#34;wb&#34;) as f:
            # noinspection PyTypeChecker
            np.save(f, value, allow_pickle=False)
        stat = self.data.stat()
        if isinstance(stat, dict):
            self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
        else:
            self._sizeof_file = stat.st_size / 1e6
        self._sizeof_path = sys.getsizeof(self.data) / 1e6
        self._time_write = time() - t0
        self._n_written += 1
        return True

    def _read(self, path: Path = None, out: bool = True) -&gt; np.ndarray:
        if path is None:
            if not self.data_format == &#34;file&#34;:
                raise ValueError(&#34;Activation vector was not saved locally : can not read it.&#34;)
            path = self.data
        t0 = time()
        with open(path, &#34;rb&#34;) as f:
            # noinspection PyTypeChecker
            value = np.load(f)
        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(value) / 1e6
            if self._nones is None:
                self._nones = np.count_nonzero(value == 1)
            self._time_read = time() - t0
            self._n_read += 1
        return value

    def _init_with_bitarray(self, value: bitarray, dtype: type, optimize: bool = True):

        &#34;&#34;&#34;
        Will set
          * self._nones (number of ones in the activation)
        if Optimize is True:
          * self.length
          * self._entropy and self._rel_entropy
          * self.data_format to &#34;bitarray&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
            memory
          * self.data as a bitarray, a str or an array
        else:
          * self.data as a bitarray
          * self.data_format to &#34;bitarray&#34;

        &#34;&#34;&#34;

        logger.debug(f&#34;Activation vector is a bitarray&#34;)
        self.length = len(value)
        self._sizeof_bitarray = sys.getsizeof(value) / 1e6
        self._nones = value.count(1)

        if optimize:
            t0 = time()
            compressed = self._compress(value, dtype=dtype)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed)) - 2
            else:
                self._entropy = len(compressed) - 2
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_bitarray:
                self.data = value
                self.data_format = &#34;bitarray&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;bitarray&#34;

    def _init_with_integer(self, value: int, dtype: type, length: int = None, optimize: bool = True):

        &#34;&#34;&#34;
        Will set
            if Optimize is True:
              * self._nones (number of ones in the activation)
              * self.length
              * if optimize is True : self._entropy and self._rel_entropy
              * self.data_format to &#34;integer&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
                memory
              * self.data as an integer, a str or an array
            else:
              * self.data as an integer
              * self.data_format to &#34;integer&#34;
        &#34;&#34;&#34;

        if length is None:
            raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)

        logger.debug(f&#34;Activation vector is an int&#34;)
        self.length = length
        self._sizeof_integer = sys.getsizeof(value) / 1e6

        if optimize:
            raw = self._integer_to_raw(value)
            self._sizeof_raw = sys.getsizeof(raw) / 1e6
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed)) - 2
            else:
                self._entropy = len(compressed) - 2
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_integer:
                self.data = value
                self.data_format = &#34;integer&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;integer&#34;

    def _init_with_str(self, value: str):
        &#34;&#34;&#34;
        will set :
          * self.data as a compressed str
          * self.data_format as &#34;compressed_str&#34;
          * self._entropy and self._rel_entropy
          * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed str&#34;)
        evaluated = np.array(ast.literal_eval(value))
        self.data = value
        self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        self._entropy = len(evaluated) - 2
        self.length = evaluated[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_str&#34;

    def _init_with_compressed_array(self, value: np.ndarray):
        &#34;&#34;&#34;
        will set :
          * self.data as a compressed array
          * self.data_format as &#34;compressed_array&#34;
          * self._entropy and self._rel_entropy
          * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed array&#34;)
        self.data = value
        self._sizeof_compressed_array = sys.getsizeof(value) / 1e6
        self._entropy = len(value) - 2
        self.length = value[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_array&#34;

    def _init_with_raw(self, value: np.ndarray, dtype: type):
        &#34;&#34;&#34;
        will set :
          * self.data as an integer or a compressed array/str depending on what takes less memory and on what dtype is
          * self.data_format as &#34;bitarray&#34;, &#34;compressed_array&#34; or &#34;compressed_str&#34;
          * self._entropy and self._rel_entropy
          * self.length
          * self._nones
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw&#34;)
        self._sizeof_raw = sys.getsizeof(value) / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        compressed = self._compress(value, dtype=dtype)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if isinstance(compressed, str):
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_str
        else:
            self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_array
        if dtype is str:
            self._entropy = len(compressed.split(&#34;,&#34;)) - 2
        else:
            self._entropy = len(compressed) - 2
        self._rel_entropy = self._entropy / self.length
        t0 = time()
        inbitarray = self._raw_to_bitarray(value)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
        self._sizeof_bitarray = sys.getsizeof(inbitarray) / 1e6
        if sys.getsizeof(inbitarray) &gt; size_compressed:
            logger.debug(f&#34;Using compressed activation representation&#34;)
            self.data = compressed
            if dtype == str:
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
        else:
            logger.debug(f&#34;Using bitarray activation representation&#34;)
            self.data_format = &#34;bitarray&#34;
            self.data = inbitarray

    def __and__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
                self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):
            return Activation(self.data &amp; a2.data, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)
        else:
            return Activation(self.raw * a2.raw, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)

    @staticmethod
    def multi_logical_and(acs: List[&#34;Activation&#34;]):
        &#34;&#34;&#34;Do logical and on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
        return Activation(np.vstack([a.raw for a in acs]).all(axis=0).astype(np.ubyte),
                          to_file=all([a.data_format == &#34;file&#34; for a in acs]))

    def __or__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
                self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):
            return Activation(self.data or a2.data, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)
        else:
            return Activation(self.raw | a2.raw, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)

    @staticmethod
    def multi_logical_or(acs: List[&#34;Activation&#34;]):
        &#34;&#34;&#34;Do logical or on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
        return Activation(np.vstack([a.raw for a in acs]).any(axis=0).astype(np.ubyte),
                          to_file=all([a.data_format == &#34;file&#34; for a in acs]))

    def __add__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != other.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {other.length}&#34;)
        if (self.data_format == &#34;bitarray&#34; and other.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and other.data_format == &#34;integer&#34;
        ):
            val_xor = self.data ^ other.data
            val_and = self.data &amp; other.data
            val = val_xor ^ val_and
        else:
            val_xor = np.logical_xor(self.raw, other.raw)
            val_and = self.raw * other.raw
            val = np.logical_xor(val_xor, val_and).astype(&#34;int32&#34;)
        return Activation(val)

    def __sub__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != other.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {other.length}&#34;)
        if (self.data_format == &#34;bitarray&#34; and other.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and other.data_format == &#34;integer&#34;
        ):
            return Activation((self.data ^ other.data) &amp; self.data)
        else:
            return Activation(np.logical_xor(self.raw, other.raw).astype(&#34;int32&#34;) * self.raw)

    def __len__(self):
        return self.length

    def _integer_to_raw(self, value: Union[int, Path] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;From a value of the form 45786542 (int), which is the base 10 representation of the binary form of an
        activation vector, returns the initial vector.
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_integer_to_raw = time() - t0
                self._n_integer_to_raw += 1
            return value

        if isinstance(value, (bitarray, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _integer_to_raw on a bitarray, raw, compressed or a path&#34;)
        if not isinstance(value, int):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.fromiter(bin(value)[2:], dtype=np.ubyte)
        if self._sizeof_integer == -1 and not out:
            self._sizeof_integer = sys.getsizeof(value) / 1e6

        if len(act) &gt; self.length:
            raise ValueError(
                &#34;After using _integer_to_raw, I ended up with an activation vector bigger than the specified &#34;
                &#34;max length. This should not happend as the max length should have been set by the indexing &#34;
                &#34;of x earlier in your code&#34;
            )
        act_bis = np.zeros(self.length).astype(np.ubyte)
        act_bis[self.length - len(act):] = act

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(act_bis) / 1e6
            self._time_integer_to_raw = time() - t0
            self._n_integer_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(act_bis == 1)
        return act_bis

    def _bitarray_to_raw(self, value: Union[bitarray, Path] = None, out=True) -&gt; np.ndarray:
        &#34;&#34;&#34;Transforms a bitarray to a nparray&#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_bitarray_to_raw = time() - t0
                self._n_bitarray_to_raw += 1
            return value

        if isinstance(value, (int, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _bitarray_to_raw on a raw, integer, compressed or a path&#34;)
        if not isinstance(value, bitarray):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.array(list(value), dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(act) / 1e6
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(value) / 1e6
            self._time_bitarray_to_raw = time() - t0
            self._n_bitarray_to_raw += 1
        return act

    def _decompress(
        self, value: Union[str, np.ndarray, Path] = None, raw=True, out=True
    ) -&gt; Union[np.ndarray, bitarray]:
        &#34;&#34;&#34;Will return the original activation vector, and set self._nones

        If raw is True (default), returns it as a np.ndarray, else as a bitarray
        &#34;&#34;&#34;
        t0 = time()

        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, (int, bitarray, Path)):
            raise TypeError(&#34;Can not apply _decompress on a bitarray, integer or Path&#34;)
        if not isinstance(value, (str, np.ndarray)):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)

        if value[-1] == 0 or value[-1] == 1:
            if not out:
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
            return value

        if isinstance(value, str):
            act = ast.literal_eval(value)
            if self._sizeof_compressed_str == -1 and not out:
                self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        elif isinstance(value, np.ndarray):
            act = value
            if self._sizeof_compressed_array == -1 and not out:
                self._sizeof_compressed_array = sys.getsizeof(value) / 1e6
        else:
            raise TypeError(f&#34;&#39;value&#39; can not be of type {type(value)}&#34;)

        length = act[-1]
        s = np.zeros(length, dtype=np.ubyte)
        previous_value = 0
        previous_index = 0

        if act[0] == 1:
            previous_value = 1
            s[0] = 1
        if len(act) == 2:
            if act[0] == 1:
                s = np.ones(length, dtype=np.ubyte)
            if raw:
                act = np.array(s, dtype=np.ubyte)
            else:
                # noinspection PyTypeChecker
                act = bitarray(s.tolist())

            if not out:
                if self._sizeof_raw == -1:
                    self._sizeof_raw = sys.getsizeof(act) / 1e6
                if self._nones is None:
                    self._nones = np.count_nonzero(act == 1)
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
            return act

        for index in act[1:]:
            if previous_value == 0:
                previous_index = index
                previous_value = 1
            else:
                s[previous_index:index] = np.ones(index - previous_index)
                previous_index = index
                previous_value = 0

        if raw:
            act = np.array(s, dtype=np.ubyte)
            if not out:
                if self._sizeof_raw == -1:
                    self._sizeof_raw = sys.getsizeof(act) / 1e6
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
        else:
            # noinspection PyTypeChecker
            act = bitarray(s.tolist())
            if not out:
                if self._sizeof_bitarray == -1:
                    self._sizeof_bitarray = sys.getsizeof(act) / 1e6
                self._time_compressed_to_bitarray = time() - t0
                self._n_compressed_to_bitarray += 1
        if self._nones is None:
            self._nones = np.count_nonzero(act == 1)
        return act

    def __contains__(self, other: &#34;Activation&#34;) -&gt; bool:
        intersection = self and other
        nones_intersection = intersection.nones
        intersection.delete()
        if nones_intersection &lt; min(self.nones, other.nones):
            return False
        return True

    @staticmethod
    def _compress(value: Union[np.ndarray, bitarray], dtype: type = str) -&gt; Union[np.ndarray, str]:
        &#34;&#34;&#34;Transforms a raw or bitarray activation vector to a compressed one.

        A compressed vector is a collection of integers starting by the initial value of the raw vector (0 or 1) and
        ending with its size. The other integers in the compression are the positions in the raw vector where the
        vector value changes. This stores all the information and saves up memory if the vector is constant over
        large periods of time.

        The compressed vector can be stored as a str looking like &#34;0, 12, 456, ..., 47782&#34; or as a numpy array of
        integers. What storage to use is specified by the &#34;dtype&#34; argument.
        &#34;&#34;&#34;
        if isinstance(value, int):
            raise TypeError(&#34;Can not compress an integer vector&#34;)
        if not isinstance(value, (np.ndarray, bitarray)) or (value[-1] != 0 and value[-1] != 1):
            if isinstance(value, str):
                return np.array(value.split(&#34;,&#34;)).astype(np.ubyte)
            return value
        if isinstance(value, np.ndarray):
            # not ubyte (unsigned byte), because np.diff will produce negative value that ubyte can not handle
            value = value.astype(np.byte)
        else:
            value = np.diff(np.array(list(value)))
        to_ret = [value[0]]
        diff_arr = abs(np.diff(value))
        to_ret += list(np.where(diff_arr == 1)[0] + 1)
        to_ret.append(len(value))
        if dtype == str:
            to_ret = str(to_ret).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        else:
            if to_ret[-1] &lt; MAX_INT_32:
                to_ret = np.array(to_ret, dtype=&#34;int32&#34;)
            else:
                to_ret = np.array(to_ret, dtype=&#34;int64&#34;)
        return to_ret

    @staticmethod
    def _raw_to_bitarray(value: np.ndarray) -&gt; bitarray:
        &#34;&#34;&#34;Casts a raw activation vector into a bitarray&#34;&#34;&#34;
        if isinstance(value, bitarray):
            return value
        elif not isinstance(value, np.ndarray) or (value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a compressed vector&#34;)
        elif isinstance(value, int):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a integer vector&#34;)
        # noinspection PyTypeChecker
        return bitarray(value.tolist())

    @staticmethod
    def _raw_to_integer(value: np.ndarray) -&gt; int:
        &#34;&#34;&#34;Casts a raw activation vector into the integer represented by its binary form
        Examples
        --------
        &gt;&gt;&gt; from ruleskit import Activation
        &gt;&gt;&gt; Activation._raw_to_integer(np.array([0, 1, 1, 0]))
        6  # the binary number &#39;0110&#39; is 6 in base 10
        &#34;&#34;&#34;
        if isinstance(value, int):
            return value
        elif not isinstance(value, np.ndarray) or (value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_integer or a compressed vector&#34;)
        elif isinstance(value, bitarray):
            raise TypeError(&#34;Can not use _raw_to_integer on a bitarray vector&#34;)
        to_ret = int(&#34;&#34;.join(str(i) for i in value.astype(np.ubyte)), 2)
        return to_ret

    @property
    def raw(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the raw np.array. Will set relevant sizes if this has not been done yet&#34;&#34;&#34;
        if self.data_format == &#34;bitarray&#34;:
            return self._bitarray_to_raw()
        elif self.data_format == &#34;integer&#34;:
            return self._integer_to_raw()
        elif self.data_format == &#34;file&#34;:
            return self._read(out=False)
        elif &#34;compressed&#34; in self.data_format:
            return self._decompress()
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def ones(self) -&gt; np.ndarray:
        &#34;&#34;&#34; Contrary to other @properties, do not store &#39;ones&#39; in array. Since it is the list of indexes where the
        vector is one, &#39;ones&#39; can be big : several MB or more. &#34;&#34;&#34;
        raw = self.raw
        ones = np.where(raw == 1)[0].tolist()
        return ones

    @property
    def nones(self) -&gt; int:
        &#34;&#34;&#34;self._nones might not be set since it can only be set at object creation if the full array was given&#34;&#34;&#34;
        if self._nones is None:
            _ = self.raw  # calling raw will compute nones and ones

        if self._coverage is None:
            self._coverage = self._nones / self.length
        return self._nones

    @property
    def entropy(self) -&gt; int:
        if self._entropy is None:
            t0 = time()
            fmt = self.data_format
            if self.data_format == &#34;file&#34;:
                data = self._read(out=False)
            else:
                data = self.data
            compressed = self._compress(data)

            if fmt == &#34;bitarray&#34;:
                self._time_bitarray_to_compressed = time() - t0
                self._n_bitarray_to_compressed += 1
            else:
                self._time_integer_to_compressed = time() - t0
                self._n_integer_to_compressed += 1

            if self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6

            self._entropy = len(ast.literal_eval(compressed)) - 2
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return self._entropy

    @property
    def rel_entropy(self) -&gt; float:
        if self._rel_entropy is None:
            _ = self.entropy  # will set self._rel_entropy
        return self._rel_entropy

    @property
    def coverage(self) -&gt; float:
        if self._coverage is None:
            _ = self.nones  # will set self._coverage
        return self._coverage

    @property
    def as_bitarray(self):
        if self.data_format == &#34;bitarray&#34;:
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;integer&#34;:
            raw = self.raw
            t0 = time()
            to_ret = self._raw_to_bitarray(raw)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret)
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            t0 = time()
            to_ret = self._decompress(raw=False)
            self._time_compressed_to_bitarray = time() - t0
            self._n_compressed_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            return self._raw_to_bitarray(data)
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_integer(self):
        if self.data_format == &#34;integer&#34;:
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(self.data)
            return self.data
        else:
            t0 = time()
            to_ret = self._raw_to_integer(self.raw)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret)
            return to_ret

    @property
    def as_compressed(self):
        if self.data_format == &#34;compressed_array&#34;:
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;compressed_str&#34;:
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed_array(self):
        if self.data_format == &#34;compressed_array&#34;:
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(self.data)
            return self.data
        if self.data_format == &#34;compressed_str&#34;:
            to_ret = np.array(ast.literal_eval(self.data))
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=np.ndarray)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=np.ndarray)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed_str(self):
        if self.data_format == &#34;compressed_str&#34;:
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return self.data
        if self.data_format == &#34;compressed_array&#34;:
            to_ret = str(self.data).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=str)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=str)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def sizeof_path(self):  # Can not force stat for file
        return self._sizeof_path

    @property
    def sizeof_file(self):  # Can not force stat for file
        return self._sizeof_file

    @property
    def sizeof_raw(self):
        if self._sizeof_raw == -1 and Activation.FORCE_STAT:
            _ = self.raw
        return self._sizeof_raw

    @property
    def sizeof_bitarray(self):
        if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
            _ = self.as_bitarray
        return self._sizeof_bitarray

    @property
    def sizeof_integer(self):
        if self._sizeof_integer == -1 and Activation.FORCE_STAT:
            _ = self.as_integer
        return self._sizeof_integer

    @property
    def sizeof_compressed_array(self):
        if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_array
        return self._sizeof_compressed_array

    @property
    def sizeof_compressed_str(self):
        if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_str
        return self._sizeof_compressed_str

    @property
    def time_write(self):  # Can not force write : would need to provide a name
        return self._time_write

    @property
    def time_read(self):  # Can not force read : file might not exist
        return self._time_read

    @property
    def time_raw_to_compressed(self):
        if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._compress(self.raw)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        return self._time_raw_to_compressed

    @property
    def time_raw_to_integer(self):
        if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._raw_to_integer(self.raw)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
        return self._time_raw_to_integer

    @property
    def time_raw_to_bitarray(self):
        if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._raw_to_bitarray(self.raw)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
        return self._time_raw_to_bitarray

    @property
    def time_compressed_to_raw(self):
        if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._decompress(self.as_compressed, out=False)
        return self._time_compressed_to_raw

    @property
    def time_bitarray_to_raw(self):
        if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._bitarray_to_raw(self.as_bitarray, out=False)
        return self._time_bitarray_to_raw

    @property
    def time_integer_to_raw(self):
        if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._integer_to_raw(self.as_integer, out=False)
        return self._time_integer_to_raw

    @property
    def time_compressed_to_bitarray(self):
        if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
            _ = self._decompress(self.as_bitarray, raw=False)
        return self._time_compressed_to_bitarray

    @property
    def time_bitarray_to_compressed(self):
        if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
            b = self.as_bitarray
            t0 = time()
            _ = self._compress(b)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
        return self._time_bitarray_to_compressed

    @property
    def time_integer_to_compressed(self):
        if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
            i = self.as_integer
            t0 = time()
            _ = self._compress(i)
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
        return self._time_integer_to_compressed

    @property
    def n_written(self):
        return self._n_written

    @property
    def n_read(self):
        return self._n_read

    @property
    def n_raw_to_compressed(self):
        return self._n_raw_to_compressed

    @property
    def n_compressed_to_raw(self):
        return self._n_compressed_to_raw

    @property
    def n_raw_to_bitarray(self):
        return self._n_raw_to_bitarray

    @property
    def n_raw_to_integer(self):
        return self._n_raw_to_integer

    @property
    def n_bitarray_to_raw(self):
        return self._n_bitarray_to_raw

    @property
    def n_integer_to_raw(self):
        return self._n_integer_to_raw

    @property
    def n_bitarray_to_compressed(self):
        return self._n_bitarray_to_compressed

    @property
    def n_integer_to_compressed(self):
        return self._n_integer_to_compressed

    @property
    def n_compressed_to_bitarray(self):
        return self._n_compressed_to_bitarray

    @property
    def n_compressed_to_integer(self):
        return self._n_compressed_to_integer</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.activation.Activation"><code class="flex name class">
<span>class <span class="ident">Activation</span></span>
<span>(</span><span>activation:Union[numpy.ndarray,bitarray.bitarray,str,int]=None, optimize:bool=True, length:int=None, to_file:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Compresses an activation vector into a str(list) describing its variations or an bitarray of booleans</p>
<p>stored data will be either a str(list):
Compression is done : First element of the list is the first value of the array last element of the list is
the length of the array The other elemnts are the coordinates that changed values
or a np.ndarray:
same as str(list) but the list is casted into np.array instead of str
or an bitarray:
The input vector [1 0 0 1 0 0 0 1 1&hellip;] where each entry uses up one bit of memory
or an integer
taking the input vector [1 0 0 1 0 0 0 1 1&hellip;], converts it to binary string representation :
"100100011&hellip;" then cast it into int using int(s, 2). This is done if Activation.WILL_COMPARE is True :
converting to int is slower than to bit array, but comparing ints is faster. Size is equivalent to bitarray.
or in a file stored locally.
This is done if name_for_file is not None</p>
<p>The method will choose how to store the data based on the size (in MB) of the compressed list : if it is
superior than in bitarray/int, it will take less memory and is prefered. If compression is used and
dtype is np.ndarray, will check that numbers present in the compressed vector can be stored as int32 to gain
memory. Else, uses int64.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>activation</code></strong> :&ensp;<code>Union[np.ndarray, bitarray, str, int]</code></dt>
<dd>If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
If str : compressed vector
If bitarray : same as np.array but takes 64x less memory (each entry is stored in one bit only)
If int : as an integer</dd>
<dt><strong><code>optimize</code></strong> :&ensp;<code>bool</code></dt>
<dd>Only relevent 'value' is an bitarray or integer. In that case, will check whether using compression saves up
memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy is
computed.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Only valid if 'value' is an integer. An activation vector stored as an integer has lost the information
about its size : [0 0 0 1 0 0 0 1 1&hellip;] to nit gives 100011&hellip; which in turn gives back [1 0 0 0 1 1&hellip;].
To get the leading zeros back, one must specify the length of the activation vector.</dd>
<dt><strong><code>to_file</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, then activation vector is stored in a file in
Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt (default value = False)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Activation(ABC):

    DTYPE = str
    FORCE_STAT = False
    WILL_COMPARE = False
    DEFAULT_TEMPDIR = Path(gettempdir())

    @classmethod
    def clean_files(cls):
        for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
            path.unlink()

    def __init__(
        self,
        activation: Union[np.ndarray, bitarray, str, int] = None,
        optimize: bool = True,
        length: int = None,
        to_file: bool = False,
    ):
        &#34;&#34;&#34;Compresses an activation vector into a str(list) describing its variations or an bitarray of booleans

        stored data will be either a str(list):
            Compression is done : First element of the list is the first value of the array last element of the list is
            the length of the array The other elemnts are the coordinates that changed values
        or a np.ndarray:
            same as str(list) but the list is casted into np.array instead of str
        or an bitarray:
            The input vector [1 0 0 1 0 0 0 1 1...] where each entry uses up one bit of memory
        or an integer
            taking the input vector [1 0 0 1 0 0 0 1 1...], converts it to binary string representation :
            &#34;100100011...&#34; then cast it into int using int(s, 2). This is done if Activation.WILL_COMPARE is True :
            converting to int is slower than to bit array, but comparing ints is faster. Size is equivalent to bitarray.
        or in a file stored locally.
            This is done if name_for_file is not None

        The method will choose how to store the data based on the size (in MB) of the compressed list : if it is
        superior than in bitarray/int, it will take less memory and is prefered. If compression is used and
        dtype is np.ndarray, will check that numbers present in the compressed vector can be stored as int32 to gain
        memory. Else, uses int64.

        Parameters
        ----------
        activation: Union[np.ndarray, bitarray, str, int]
            If np.ndarray : Of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1], or compressed vector
            If str : compressed vector
            If bitarray : same as np.array but takes 64x less memory (each entry is stored in one bit only)
            If int : as an integer
        optimize: bool
            Only relevent &#39;value&#39; is an bitarray or integer. In that case, will check whether using compression saves up
            memory. Else, does not check and uses bitarray or integer. Note that if optimize is True, entropy is
            computed.
        length: int
            Only valid if &#39;value&#39; is an integer. An activation vector stored as an integer has lost the information
            about its size : [0 0 0 1 0 0 0 1 1...] to nit gives 100011... which in turn gives back [1 0 0 0 1 1...].
            To get the leading zeros back, one must specify the length of the activation vector.
        to_file: bool
            If True, then activation vector is stored in a file in
            Activation.DEFAULT_TEMPDIR / ACTIVATION_VECTOR_available_number.txt (default value = False)
        &#34;&#34;&#34;
        self.optimize = optimize
        self.length = None  # Will be set by init methods
        self._entropy = None  # Will be set if activation is not an integer or if optimize is True
        self.data_format = None  # Will be set by init methods
        self.data = None  # Will be set by init methods
        self._rel_entropy = None  # Will be set if activation is not an integer or if optimize is True
        self._nones = None  # Will be set if activation is not an integer or if optimize is True
        self._coverage = None
        self._time_write = -1
        self._time_read = -1
        self._time_compressed_to_raw = -1
        self._time_raw_to_compressed = -1
        self._time_raw_to_integer = -1
        self._time_bitarray_to_raw = -1
        self._time_raw_to_bitarray = -1
        self._time_compressed_to_bitarray = -1
        self._time_bitarray_to_compressed = -1
        self._time_integer_to_compressed = -1
        self._time_integer_to_raw = -1
        self._n_written = 0
        self._n_read = 0
        self._n_compressed_to_raw = 0
        self._n_raw_to_compressed = 0
        self._n_bitarray_to_raw = 0
        self._n_integer_to_raw = 0
        self._n_raw_to_bitarray = 0
        self._n_raw_to_integer = 0
        self._n_bitarray_to_compressed = 0
        self._n_integer_to_compressed = 0
        self._n_compressed_to_bitarray = 0
        self._n_compressed_to_integer = 0
        self._sizeof_compressed_array = -1
        self._sizeof_compressed_str = -1
        self._sizeof_bitarray = -1
        self._sizeof_integer = -1
        self._sizeof_raw = -1
        self._sizeof_file = -1
        self._sizeof_path = -1

        if isinstance(activation, str) and &#34;,&#34; not in activation:
            if Activation.WILL_COMPARE:
                activation = int(activation, 2)
            else:
                activation = bitarray(activation)

        if isinstance(activation, bitarray):
            self._init_with_bitarray(activation, Activation.DTYPE, optimize)

        elif isinstance(activation, int):
            self._init_with_integer(activation, Activation.DTYPE, length, optimize)

        elif isinstance(activation, str):
            self._init_with_str(activation)

        elif isinstance(activation, np.ndarray):
            if activation[-1] &gt; 1:
                self._init_with_compressed_array(activation)
            else:
                if to_file:
                    if not self._write(activation):
                        self._init_with_raw(activation, Activation.DTYPE)
                else:
                    self._init_with_raw(activation, Activation.DTYPE)
        else:
            raise TypeError(
                f&#34;An activation can only be a np.ndarray, and bitarray, a str or an integer. Got&#34;
                f&#34; {type(activation)}.&#34;
            )

    def __copy__(self):
        if self.data_format == &#34;integer&#34;:
            return Activation(self.raw, optimize=self.optimize, length=self.length)
        return Activation(self.raw, optimize=self.optimize, to_file=self.data_format == &#34;file&#34;)

    # def __del__(self):
    #     if hasattr(self, &#34;data&#34;) and hasattr(self, &#34;data_format&#34;) and self.data_format == &#34;file&#34;:
    #         if self.data.is_file():
    #             self.data.unlink()

    def delete(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data&#34;&#34;&#34;
        if self.data_format == &#34;file&#34;:
            if self.data.is_file():
                self.data.unlink()
        else:
            del self.data
            self.data = None

    def _write(self, value: np.ndarray):

        logger.debug(f&#34;Activation vector is raw, store it in a file&#34;)
        self._sizeof_raw = sys.getsizeof(value) / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        arange = (0, int(1e64))
        number = random.randint(*arange)
        data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        attempts = 0
        while data.is_file():
            if attempts &gt; 99:
                logger.warning(&#34;Failed to save activation vector locally after 100 attempts at finding an available&#34;
                               &#34; name. Will keep it in RAM.&#34;)
                return False
            number += 1
            attempts += 1
            data = Activation.DEFAULT_TEMPDIR / f&#34;ACTIVATION_VECTOR_{number}.txt&#34;
        data.touch()
        self.data = data
        self.data_format = &#34;file&#34;
        with open(self.data, &#34;wb&#34;) as f:
            # noinspection PyTypeChecker
            np.save(f, value, allow_pickle=False)
        stat = self.data.stat()
        if isinstance(stat, dict):
            self._sizeof_file = stat[&#34;st_size&#34;] / 1e6
        else:
            self._sizeof_file = stat.st_size / 1e6
        self._sizeof_path = sys.getsizeof(self.data) / 1e6
        self._time_write = time() - t0
        self._n_written += 1
        return True

    def _read(self, path: Path = None, out: bool = True) -&gt; np.ndarray:
        if path is None:
            if not self.data_format == &#34;file&#34;:
                raise ValueError(&#34;Activation vector was not saved locally : can not read it.&#34;)
            path = self.data
        t0 = time()
        with open(path, &#34;rb&#34;) as f:
            # noinspection PyTypeChecker
            value = np.load(f)
        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(value) / 1e6
            if self._nones is None:
                self._nones = np.count_nonzero(value == 1)
            self._time_read = time() - t0
            self._n_read += 1
        return value

    def _init_with_bitarray(self, value: bitarray, dtype: type, optimize: bool = True):

        &#34;&#34;&#34;
        Will set
          * self._nones (number of ones in the activation)
        if Optimize is True:
          * self.length
          * self._entropy and self._rel_entropy
          * self.data_format to &#34;bitarray&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
            memory
          * self.data as a bitarray, a str or an array
        else:
          * self.data as a bitarray
          * self.data_format to &#34;bitarray&#34;

        &#34;&#34;&#34;

        logger.debug(f&#34;Activation vector is a bitarray&#34;)
        self.length = len(value)
        self._sizeof_bitarray = sys.getsizeof(value) / 1e6
        self._nones = value.count(1)

        if optimize:
            t0 = time()
            compressed = self._compress(value, dtype=dtype)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed)) - 2
            else:
                self._entropy = len(compressed) - 2
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_bitarray:
                self.data = value
                self.data_format = &#34;bitarray&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;bitarray&#34;

    def _init_with_integer(self, value: int, dtype: type, length: int = None, optimize: bool = True):

        &#34;&#34;&#34;
        Will set
            if Optimize is True:
              * self._nones (number of ones in the activation)
              * self.length
              * if optimize is True : self._entropy and self._rel_entropy
              * self.data_format to &#34;integer&#34; or &#34;compressed_str&#34; or &#34;compressed_array&#34; depending on what takes less
                memory
              * self.data as an integer, a str or an array
            else:
              * self.data as an integer
              * self.data_format to &#34;integer&#34;
        &#34;&#34;&#34;

        if length is None:
            raise ValueError(&#34;When giving an integer to Activation, you must also specify its length.&#34;)

        logger.debug(f&#34;Activation vector is an int&#34;)
        self.length = length
        self._sizeof_integer = sys.getsizeof(value) / 1e6

        if optimize:
            raw = self._integer_to_raw(value)
            self._sizeof_raw = sys.getsizeof(raw) / 1e6
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            compressed = self._compress(raw, dtype=dtype)
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
            if isinstance(compressed, str):
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_str
            else:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
                size_compressed = self._sizeof_compressed_array
            if dtype == str:
                self._entropy = len(ast.literal_eval(compressed)) - 2
            else:
                self._entropy = len(compressed) - 2
            self._rel_entropy = self._entropy / self.length
            if size_compressed &gt; self._sizeof_integer:
                self.data = value
                self.data_format = &#34;integer&#34;
            else:
                self.data = compressed
                if dtype == str:
                    self.data_format = &#34;compressed_str&#34;
                else:
                    self.data_format = &#34;compressed_array&#34;
        else:
            self.data = value
            self.data_format = &#34;integer&#34;

    def _init_with_str(self, value: str):
        &#34;&#34;&#34;
        will set :
          * self.data as a compressed str
          * self.data_format as &#34;compressed_str&#34;
          * self._entropy and self._rel_entropy
          * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed str&#34;)
        evaluated = np.array(ast.literal_eval(value))
        self.data = value
        self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        self._entropy = len(evaluated) - 2
        self.length = evaluated[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_str&#34;

    def _init_with_compressed_array(self, value: np.ndarray):
        &#34;&#34;&#34;
        will set :
          * self.data as a compressed array
          * self.data_format as &#34;compressed_array&#34;
          * self._entropy and self._rel_entropy
          * self.length
        &#34;&#34;&#34;
        logger.debug(f&#34;Activation vector is a compressed array&#34;)
        self.data = value
        self._sizeof_compressed_array = sys.getsizeof(value) / 1e6
        self._entropy = len(value) - 2
        self.length = value[-1]
        self._rel_entropy = self._entropy / self.length
        self.data_format = &#34;compressed_array&#34;

    def _init_with_raw(self, value: np.ndarray, dtype: type):
        &#34;&#34;&#34;
        will set :
          * self.data as an integer or a compressed array/str depending on what takes less memory and on what dtype is
          * self.data_format as &#34;bitarray&#34;, &#34;compressed_array&#34; or &#34;compressed_str&#34;
          * self._entropy and self._rel_entropy
          * self.length
          * self._nones
        &#34;&#34;&#34;
        if value.dtype != np.ubyte:
            value = value.astype(np.ubyte)
        logger.debug(f&#34;Activation vector is raw&#34;)
        self._sizeof_raw = sys.getsizeof(value) / 1e6
        self.length = len(value)
        self._nones = np.count_nonzero(value == 1)
        t0 = time()
        compressed = self._compress(value, dtype=dtype)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if isinstance(compressed, str):
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_str
        else:
            self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6
            size_compressed = self._sizeof_compressed_array
        if dtype is str:
            self._entropy = len(compressed.split(&#34;,&#34;)) - 2
        else:
            self._entropy = len(compressed) - 2
        self._rel_entropy = self._entropy / self.length
        t0 = time()
        inbitarray = self._raw_to_bitarray(value)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
        self._sizeof_bitarray = sys.getsizeof(inbitarray) / 1e6
        if sys.getsizeof(inbitarray) &gt; size_compressed:
            logger.debug(f&#34;Using compressed activation representation&#34;)
            self.data = compressed
            if dtype == str:
                self.data_format = &#34;compressed_str&#34;
            else:
                self.data_format = &#34;compressed_array&#34;
        else:
            logger.debug(f&#34;Using bitarray activation representation&#34;)
            self.data_format = &#34;bitarray&#34;
            self.data = inbitarray

    def __and__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
                self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):
            return Activation(self.data &amp; a2.data, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)
        else:
            return Activation(self.raw * a2.raw, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)

    @staticmethod
    def multi_logical_and(acs: List[&#34;Activation&#34;]):
        &#34;&#34;&#34;Do logical and on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
        return Activation(np.vstack([a.raw for a in acs]).all(axis=0).astype(np.ubyte),
                          to_file=all([a.data_format == &#34;file&#34; for a in acs]))

    def __or__(self, a2: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != a2.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {a2.length}&#34;)

        if (self.data_format == &#34;bitarray&#34; and a2.data_format == &#34;bitarray&#34;) or (
                self.data_format == &#34;integer&#34; and a2.data_format == &#34;integer&#34;
        ):
            return Activation(self.data or a2.data, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)
        else:
            return Activation(self.raw | a2.raw, to_file=self.data_format == &#34;file&#34; and a2.data_format == &#34;file&#34;)

    @staticmethod
    def multi_logical_or(acs: List[&#34;Activation&#34;]):
        &#34;&#34;&#34;Do logical or on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
        if len(acs) == 1:
            return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
        return Activation(np.vstack([a.raw for a in acs]).any(axis=0).astype(np.ubyte),
                          to_file=all([a.data_format == &#34;file&#34; for a in acs]))

    def __add__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != other.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {other.length}&#34;)
        if (self.data_format == &#34;bitarray&#34; and other.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and other.data_format == &#34;integer&#34;
        ):
            val_xor = self.data ^ other.data
            val_and = self.data &amp; other.data
            val = val_xor ^ val_and
        else:
            val_xor = np.logical_xor(self.raw, other.raw)
            val_and = self.raw * other.raw
            val = np.logical_xor(val_xor, val_and).astype(&#34;int32&#34;)
        return Activation(val)

    def __sub__(self, other: &#34;Activation&#34;) -&gt; &#34;Activation&#34;:
        if self.length != other.length:
            raise ValueError(f&#34;Activations have different lengths. Left is {self.length}, right is {other.length}&#34;)
        if (self.data_format == &#34;bitarray&#34; and other.data_format == &#34;bitarray&#34;) or (
            self.data_format == &#34;integer&#34; and other.data_format == &#34;integer&#34;
        ):
            return Activation((self.data ^ other.data) &amp; self.data)
        else:
            return Activation(np.logical_xor(self.raw, other.raw).astype(&#34;int32&#34;) * self.raw)

    def __len__(self):
        return self.length

    def _integer_to_raw(self, value: Union[int, Path] = None, out: bool = True) -&gt; np.ndarray:
        &#34;&#34;&#34;From a value of the form 45786542 (int), which is the base 10 representation of the binary form of an
        activation vector, returns the initial vector.
        &#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_integer_to_raw = time() - t0
                self._n_integer_to_raw += 1
            return value

        if isinstance(value, (bitarray, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _integer_to_raw on a bitarray, raw, compressed or a path&#34;)
        if not isinstance(value, int):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.fromiter(bin(value)[2:], dtype=np.ubyte)
        if self._sizeof_integer == -1 and not out:
            self._sizeof_integer = sys.getsizeof(value) / 1e6

        if len(act) &gt; self.length:
            raise ValueError(
                &#34;After using _integer_to_raw, I ended up with an activation vector bigger than the specified &#34;
                &#34;max length. This should not happend as the max length should have been set by the indexing &#34;
                &#34;of x earlier in your code&#34;
            )
        act_bis = np.zeros(self.length).astype(np.ubyte)
        act_bis[self.length - len(act):] = act

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(act_bis) / 1e6
            self._time_integer_to_raw = time() - t0
            self._n_integer_to_raw += 1
            if self._nones is None:
                self._nones = np.count_nonzero(act_bis == 1)
        return act_bis

    def _bitarray_to_raw(self, value: Union[bitarray, Path] = None, out=True) -&gt; np.ndarray:
        &#34;&#34;&#34;Transforms a bitarray to a nparray&#34;&#34;&#34;
        t0 = time()
        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, np.ndarray) and (value[-1] == 0 or value[-1] == 1):
            if not out:
                self._time_bitarray_to_raw = time() - t0
                self._n_bitarray_to_raw += 1
            return value

        if isinstance(value, (int, np.ndarray, str, Path)):
            raise TypeError(&#34;Can not apply _bitarray_to_raw on a raw, integer, compressed or a path&#34;)
        if not isinstance(value, bitarray):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)
        act = np.array(list(value), dtype=np.ubyte)

        if not out:
            if self._sizeof_raw == -1:
                self._sizeof_raw = sys.getsizeof(act) / 1e6
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(value) / 1e6
            self._time_bitarray_to_raw = time() - t0
            self._n_bitarray_to_raw += 1
        return act

    def _decompress(
        self, value: Union[str, np.ndarray, Path] = None, raw=True, out=True
    ) -&gt; Union[np.ndarray, bitarray]:
        &#34;&#34;&#34;Will return the original activation vector, and set self._nones

        If raw is True (default), returns it as a np.ndarray, else as a bitarray
        &#34;&#34;&#34;
        t0 = time()

        if value is None:
            out = False
            if self.data_format == &#34;file&#34;:
                value = self._read(out=False)
            else:
                value = self.data

        if isinstance(value, (int, bitarray, Path)):
            raise TypeError(&#34;Can not apply _decompress on a bitarray, integer or Path&#34;)
        if not isinstance(value, (str, np.ndarray)):
            raise TypeError(f&#34;Invalid format {type(value)}&#34;)

        if value[-1] == 0 or value[-1] == 1:
            if not out:
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
            return value

        if isinstance(value, str):
            act = ast.literal_eval(value)
            if self._sizeof_compressed_str == -1 and not out:
                self._sizeof_compressed_str = sys.getsizeof(value) / 1e6
        elif isinstance(value, np.ndarray):
            act = value
            if self._sizeof_compressed_array == -1 and not out:
                self._sizeof_compressed_array = sys.getsizeof(value) / 1e6
        else:
            raise TypeError(f&#34;&#39;value&#39; can not be of type {type(value)}&#34;)

        length = act[-1]
        s = np.zeros(length, dtype=np.ubyte)
        previous_value = 0
        previous_index = 0

        if act[0] == 1:
            previous_value = 1
            s[0] = 1
        if len(act) == 2:
            if act[0] == 1:
                s = np.ones(length, dtype=np.ubyte)
            if raw:
                act = np.array(s, dtype=np.ubyte)
            else:
                # noinspection PyTypeChecker
                act = bitarray(s.tolist())

            if not out:
                if self._sizeof_raw == -1:
                    self._sizeof_raw = sys.getsizeof(act) / 1e6
                if self._nones is None:
                    self._nones = np.count_nonzero(act == 1)
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
            return act

        for index in act[1:]:
            if previous_value == 0:
                previous_index = index
                previous_value = 1
            else:
                s[previous_index:index] = np.ones(index - previous_index)
                previous_index = index
                previous_value = 0

        if raw:
            act = np.array(s, dtype=np.ubyte)
            if not out:
                if self._sizeof_raw == -1:
                    self._sizeof_raw = sys.getsizeof(act) / 1e6
                self._time_compressed_to_raw = time() - t0
                self._n_compressed_to_raw += 1
        else:
            # noinspection PyTypeChecker
            act = bitarray(s.tolist())
            if not out:
                if self._sizeof_bitarray == -1:
                    self._sizeof_bitarray = sys.getsizeof(act) / 1e6
                self._time_compressed_to_bitarray = time() - t0
                self._n_compressed_to_bitarray += 1
        if self._nones is None:
            self._nones = np.count_nonzero(act == 1)
        return act

    def __contains__(self, other: &#34;Activation&#34;) -&gt; bool:
        intersection = self and other
        nones_intersection = intersection.nones
        intersection.delete()
        if nones_intersection &lt; min(self.nones, other.nones):
            return False
        return True

    @staticmethod
    def _compress(value: Union[np.ndarray, bitarray], dtype: type = str) -&gt; Union[np.ndarray, str]:
        &#34;&#34;&#34;Transforms a raw or bitarray activation vector to a compressed one.

        A compressed vector is a collection of integers starting by the initial value of the raw vector (0 or 1) and
        ending with its size. The other integers in the compression are the positions in the raw vector where the
        vector value changes. This stores all the information and saves up memory if the vector is constant over
        large periods of time.

        The compressed vector can be stored as a str looking like &#34;0, 12, 456, ..., 47782&#34; or as a numpy array of
        integers. What storage to use is specified by the &#34;dtype&#34; argument.
        &#34;&#34;&#34;
        if isinstance(value, int):
            raise TypeError(&#34;Can not compress an integer vector&#34;)
        if not isinstance(value, (np.ndarray, bitarray)) or (value[-1] != 0 and value[-1] != 1):
            if isinstance(value, str):
                return np.array(value.split(&#34;,&#34;)).astype(np.ubyte)
            return value
        if isinstance(value, np.ndarray):
            # not ubyte (unsigned byte), because np.diff will produce negative value that ubyte can not handle
            value = value.astype(np.byte)
        else:
            value = np.diff(np.array(list(value)))
        to_ret = [value[0]]
        diff_arr = abs(np.diff(value))
        to_ret += list(np.where(diff_arr == 1)[0] + 1)
        to_ret.append(len(value))
        if dtype == str:
            to_ret = str(to_ret).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        else:
            if to_ret[-1] &lt; MAX_INT_32:
                to_ret = np.array(to_ret, dtype=&#34;int32&#34;)
            else:
                to_ret = np.array(to_ret, dtype=&#34;int64&#34;)
        return to_ret

    @staticmethod
    def _raw_to_bitarray(value: np.ndarray) -&gt; bitarray:
        &#34;&#34;&#34;Casts a raw activation vector into a bitarray&#34;&#34;&#34;
        if isinstance(value, bitarray):
            return value
        elif not isinstance(value, np.ndarray) or (value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a compressed vector&#34;)
        elif isinstance(value, int):
            raise TypeError(&#34;Can not use _raw_to_bitarray on a integer vector&#34;)
        # noinspection PyTypeChecker
        return bitarray(value.tolist())

    @staticmethod
    def _raw_to_integer(value: np.ndarray) -&gt; int:
        &#34;&#34;&#34;Casts a raw activation vector into the integer represented by its binary form
        Examples
        --------
        &gt;&gt;&gt; from ruleskit import Activation
        &gt;&gt;&gt; Activation._raw_to_integer(np.array([0, 1, 1, 0]))
        6  # the binary number &#39;0110&#39; is 6 in base 10
        &#34;&#34;&#34;
        if isinstance(value, int):
            return value
        elif not isinstance(value, np.ndarray) or (value[-1] != 0 and value[-1] != 1):
            raise TypeError(&#34;Can not use _raw_to_integer or a compressed vector&#34;)
        elif isinstance(value, bitarray):
            raise TypeError(&#34;Can not use _raw_to_integer on a bitarray vector&#34;)
        to_ret = int(&#34;&#34;.join(str(i) for i in value.astype(np.ubyte)), 2)
        return to_ret

    @property
    def raw(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the raw np.array. Will set relevant sizes if this has not been done yet&#34;&#34;&#34;
        if self.data_format == &#34;bitarray&#34;:
            return self._bitarray_to_raw()
        elif self.data_format == &#34;integer&#34;:
            return self._integer_to_raw()
        elif self.data_format == &#34;file&#34;:
            return self._read(out=False)
        elif &#34;compressed&#34; in self.data_format:
            return self._decompress()
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def ones(self) -&gt; np.ndarray:
        &#34;&#34;&#34; Contrary to other @properties, do not store &#39;ones&#39; in array. Since it is the list of indexes where the
        vector is one, &#39;ones&#39; can be big : several MB or more. &#34;&#34;&#34;
        raw = self.raw
        ones = np.where(raw == 1)[0].tolist()
        return ones

    @property
    def nones(self) -&gt; int:
        &#34;&#34;&#34;self._nones might not be set since it can only be set at object creation if the full array was given&#34;&#34;&#34;
        if self._nones is None:
            _ = self.raw  # calling raw will compute nones and ones

        if self._coverage is None:
            self._coverage = self._nones / self.length
        return self._nones

    @property
    def entropy(self) -&gt; int:
        if self._entropy is None:
            t0 = time()
            fmt = self.data_format
            if self.data_format == &#34;file&#34;:
                data = self._read(out=False)
            else:
                data = self.data
            compressed = self._compress(data)

            if fmt == &#34;bitarray&#34;:
                self._time_bitarray_to_compressed = time() - t0
                self._n_bitarray_to_compressed += 1
            else:
                self._time_integer_to_compressed = time() - t0
                self._n_integer_to_compressed += 1

            if self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6

            self._entropy = len(ast.literal_eval(compressed)) - 2
        if self._rel_entropy is None:
            self._rel_entropy = self._entropy / self.length
        return self._entropy

    @property
    def rel_entropy(self) -&gt; float:
        if self._rel_entropy is None:
            _ = self.entropy  # will set self._rel_entropy
        return self._rel_entropy

    @property
    def coverage(self) -&gt; float:
        if self._coverage is None:
            _ = self.nones  # will set self._coverage
        return self._coverage

    @property
    def as_bitarray(self):
        if self.data_format == &#34;bitarray&#34;:
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;integer&#34;:
            raw = self.raw
            t0 = time()
            to_ret = self._raw_to_bitarray(raw)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret)
            return to_ret
        elif &#34;compressed&#34; in self.data_format:
            t0 = time()
            to_ret = self._decompress(raw=False)
            self._time_compressed_to_bitarray = time() - t0
            self._n_compressed_to_bitarray += 1
            if self._sizeof_bitarray == -1:
                self._sizeof_bitarray = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            return self._raw_to_bitarray(data)
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_integer(self):
        if self.data_format == &#34;integer&#34;:
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(self.data)
            return self.data
        else:
            t0 = time()
            to_ret = self._raw_to_integer(self.raw)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
            if self._sizeof_integer == -1:
                self._sizeof_integer = sys.getsizeof(to_ret)
            return to_ret

    @property
    def as_compressed(self):
        if self.data_format == &#34;compressed_array&#34;:
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;compressed_str&#34;:
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return self.data
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed_array(self):
        if self.data_format == &#34;compressed_array&#34;:
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(self.data)
            return self.data
        if self.data_format == &#34;compressed_str&#34;:
            to_ret = np.array(ast.literal_eval(self.data))
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw, dtype=np.ndarray)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=np.ndarray)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_array == -1:
                self._sizeof_compressed_array = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=np.ndarray)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def as_compressed_str(self):
        if self.data_format == &#34;compressed_str&#34;:
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(self.data)
            return self.data
        if self.data_format == &#34;compressed_array&#34;:
            to_ret = str(self.data).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;integer&#34;:
            raw = self._integer_to_raw()
            self._nones = np.count_nonzero(raw == 1)
            t0 = time()
            to_ret = self._compress(raw, dtype=str)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return to_ret
        elif self.data_format == &#34;bitarray&#34;:
            t0 = time()
            to_ret = self._compress(self.data, dtype=str)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
            if self._sizeof_compressed_str == -1:
                self._sizeof_compressed_str = sys.getsizeof(to_ret)
            return
        elif self.data_format == &#34;file&#34;:
            data = self._read(out=False)
            to_ret = self._compress(data, dtype=str)
            return to_ret
        else:
            raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)

    @property
    def sizeof_path(self):  # Can not force stat for file
        return self._sizeof_path

    @property
    def sizeof_file(self):  # Can not force stat for file
        return self._sizeof_file

    @property
    def sizeof_raw(self):
        if self._sizeof_raw == -1 and Activation.FORCE_STAT:
            _ = self.raw
        return self._sizeof_raw

    @property
    def sizeof_bitarray(self):
        if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
            _ = self.as_bitarray
        return self._sizeof_bitarray

    @property
    def sizeof_integer(self):
        if self._sizeof_integer == -1 and Activation.FORCE_STAT:
            _ = self.as_integer
        return self._sizeof_integer

    @property
    def sizeof_compressed_array(self):
        if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_array
        return self._sizeof_compressed_array

    @property
    def sizeof_compressed_str(self):
        if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
            _ = self.as_compressed_str
        return self._sizeof_compressed_str

    @property
    def time_write(self):  # Can not force write : would need to provide a name
        return self._time_write

    @property
    def time_read(self):  # Can not force read : file might not exist
        return self._time_read

    @property
    def time_raw_to_compressed(self):
        if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._compress(self.raw)
            self._time_raw_to_compressed = time() - t0
            self._n_raw_to_compressed += 1
        return self._time_raw_to_compressed

    @property
    def time_raw_to_integer(self):
        if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._raw_to_integer(self.raw)
            self._time_raw_to_integer = time() - t0
            self._n_raw_to_integer += 1
        return self._time_raw_to_integer

    @property
    def time_raw_to_bitarray(self):
        if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
            t0 = time()
            _ = self._raw_to_bitarray(self.raw)
            self._time_raw_to_bitarray = time() - t0
            self._n_raw_to_bitarray += 1
        return self._time_raw_to_bitarray

    @property
    def time_compressed_to_raw(self):
        if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._decompress(self.as_compressed, out=False)
        return self._time_compressed_to_raw

    @property
    def time_bitarray_to_raw(self):
        if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._bitarray_to_raw(self.as_bitarray, out=False)
        return self._time_bitarray_to_raw

    @property
    def time_integer_to_raw(self):
        if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
            _ = self._integer_to_raw(self.as_integer, out=False)
        return self._time_integer_to_raw

    @property
    def time_compressed_to_bitarray(self):
        if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
            _ = self._decompress(self.as_bitarray, raw=False)
        return self._time_compressed_to_bitarray

    @property
    def time_bitarray_to_compressed(self):
        if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
            b = self.as_bitarray
            t0 = time()
            _ = self._compress(b)
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
        return self._time_bitarray_to_compressed

    @property
    def time_integer_to_compressed(self):
        if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
            i = self.as_integer
            t0 = time()
            _ = self._compress(i)
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1
        return self._time_integer_to_compressed

    @property
    def n_written(self):
        return self._n_written

    @property
    def n_read(self):
        return self._n_read

    @property
    def n_raw_to_compressed(self):
        return self._n_raw_to_compressed

    @property
    def n_compressed_to_raw(self):
        return self._n_compressed_to_raw

    @property
    def n_raw_to_bitarray(self):
        return self._n_raw_to_bitarray

    @property
    def n_raw_to_integer(self):
        return self._n_raw_to_integer

    @property
    def n_bitarray_to_raw(self):
        return self._n_bitarray_to_raw

    @property
    def n_integer_to_raw(self):
        return self._n_integer_to_raw

    @property
    def n_bitarray_to_compressed(self):
        return self._n_bitarray_to_compressed

    @property
    def n_integer_to_compressed(self):
        return self._n_integer_to_compressed

    @property
    def n_compressed_to_bitarray(self):
        return self._n_compressed_to_bitarray

    @property
    def n_compressed_to_integer(self):
        return self._n_compressed_to_integer</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.activation.Activation.DEFAULT_TEMPDIR"><code class="name">var <span class="ident">DEFAULT_TEMPDIR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.activation.Activation.DTYPE"><code class="name">var <span class="ident">DTYPE</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
<dt id="ruleskit.activation.Activation.FORCE_STAT"><code class="name">var <span class="ident">FORCE_STAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ruleskit.activation.Activation.WILL_COMPARE"><code class="name">var <span class="ident">WILL_COMPARE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ruleskit.activation.Activation.clean_files"><code class="name flex">
<span>def <span class="ident">clean_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clean_files(cls):
    for path in cls.DEFAULT_TEMPDIR.glob(&#34;ACTIVATION_VECTOR_*.txt&#34;):
        path.unlink()</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.multi_logical_and"><code class="name flex">
<span>def <span class="ident">multi_logical_and</span></span>(<span>acs:List[ForwardRef('<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Do logical and on many activation vectors at once. Uses raw version to gain time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multi_logical_and(acs: List[&#34;Activation&#34;]):
    &#34;&#34;&#34;Do logical and on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
    if len(acs) == 1:
        return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
    return Activation(np.vstack([a.raw for a in acs]).all(axis=0).astype(np.ubyte),
                      to_file=all([a.data_format == &#34;file&#34; for a in acs]))</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.multi_logical_or"><code class="name flex">
<span>def <span class="ident">multi_logical_or</span></span>(<span>acs:List[ForwardRef('<a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>Do logical or on many activation vectors at once. Uses raw version to gain time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multi_logical_or(acs: List[&#34;Activation&#34;]):
    &#34;&#34;&#34;Do logical or on many activation vectors at once. Uses raw version to gain time.&#34;&#34;&#34;
    if len(acs) == 1:
        return Activation(acs[0].raw, to_file=acs[0].data_format == &#34;file&#34;)
    return Activation(np.vstack([a.raw for a in acs]).any(axis=0).astype(np.ubyte),
                      to_file=all([a.data_format == &#34;file&#34; for a in acs]))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.activation.Activation.as_bitarray"><code class="name">var <span class="ident">as_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_bitarray(self):
    if self.data_format == &#34;bitarray&#34;:
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(self.data)
        return self.data
    elif self.data_format == &#34;integer&#34;:
        raw = self.raw
        t0 = time()
        to_ret = self._raw_to_bitarray(raw)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(to_ret)
        return to_ret
    elif &#34;compressed&#34; in self.data_format:
        t0 = time()
        to_ret = self._decompress(raw=False)
        self._time_compressed_to_bitarray = time() - t0
        self._n_compressed_to_bitarray += 1
        if self._sizeof_bitarray == -1:
            self._sizeof_bitarray = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        return self._raw_to_bitarray(data)
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed"><code class="name">var <span class="ident">as_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed(self):
    if self.data_format == &#34;compressed_array&#34;:
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(self.data)
        return self.data
    elif self.data_format == &#34;compressed_str&#34;:
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(self.data)
        return self.data
    elif self.data_format == &#34;integer&#34;:
        raw = self._integer_to_raw()
        self._nones = np.count_nonzero(raw == 1)
        t0 = time()
        to_ret = self._compress(raw)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(to_ret)
        elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(self.data)
        return to_ret
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        to_ret = self._compress(self.data)
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
        if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(to_ret)
        elif self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(self.data)
        return to_ret
    elif self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        to_ret = self._compress(data)
        return to_ret
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed_array"><code class="name">var <span class="ident">as_compressed_array</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed_array(self):
    if self.data_format == &#34;compressed_array&#34;:
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(self.data)
        return self.data
    if self.data_format == &#34;compressed_str&#34;:
        to_ret = np.array(ast.literal_eval(self.data))
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;integer&#34;:
        raw = self._integer_to_raw()
        self._nones = np.count_nonzero(raw == 1)
        t0 = time()
        to_ret = self._compress(raw, dtype=np.ndarray)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        to_ret = self._compress(self.data, dtype=np.ndarray)
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
        if self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        to_ret = self._compress(data, dtype=np.ndarray)
        return to_ret
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_compressed_str"><code class="name">var <span class="ident">as_compressed_str</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_compressed_str(self):
    if self.data_format == &#34;compressed_str&#34;:
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(self.data)
        return self.data
    if self.data_format == &#34;compressed_array&#34;:
        to_ret = str(self.data).replace(&#34; &#34;, &#34;&#34;).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;)
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;integer&#34;:
        raw = self._integer_to_raw()
        self._nones = np.count_nonzero(raw == 1)
        t0 = time()
        to_ret = self._compress(raw, dtype=str)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret)
        return to_ret
    elif self.data_format == &#34;bitarray&#34;:
        t0 = time()
        to_ret = self._compress(self.data, dtype=str)
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
        if self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(to_ret)
        return
    elif self.data_format == &#34;file&#34;:
        data = self._read(out=False)
        to_ret = self._compress(data, dtype=str)
        return to_ret
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.as_integer"><code class="name">var <span class="ident">as_integer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_integer(self):
    if self.data_format == &#34;integer&#34;:
        if self._sizeof_integer == -1:
            self._sizeof_integer = sys.getsizeof(self.data)
        return self.data
    else:
        t0 = time()
        to_ret = self._raw_to_integer(self.raw)
        self._time_raw_to_integer = time() - t0
        self._n_raw_to_integer += 1
        if self._sizeof_integer == -1:
            self._sizeof_integer = sys.getsizeof(to_ret)
        return to_ret</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.coverage"><code class="name">var <span class="ident">coverage</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; float:
    if self._coverage is None:
        _ = self.nones  # will set self._coverage
    return self._coverage</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.entropy"><code class="name">var <span class="ident">entropy</span> :int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def entropy(self) -&gt; int:
    if self._entropy is None:
        t0 = time()
        fmt = self.data_format
        if self.data_format == &#34;file&#34;:
            data = self._read(out=False)
        else:
            data = self.data
        compressed = self._compress(data)

        if fmt == &#34;bitarray&#34;:
            self._time_bitarray_to_compressed = time() - t0
            self._n_bitarray_to_compressed += 1
        else:
            self._time_integer_to_compressed = time() - t0
            self._n_integer_to_compressed += 1

        if self.data_format == &#34;compressed_str&#34; and self._sizeof_compressed_str == -1:
            self._sizeof_compressed_str = sys.getsizeof(compressed) / 1e6
        if self.data_format == &#34;compressed_array&#34; and self._sizeof_compressed_array == -1:
            self._sizeof_compressed_array = sys.getsizeof(compressed) / 1e6

        self._entropy = len(ast.literal_eval(compressed)) - 2
    if self._rel_entropy is None:
        self._rel_entropy = self._entropy / self.length
    return self._entropy</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_bitarray_to_compressed"><code class="name">var <span class="ident">n_bitarray_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_bitarray_to_compressed(self):
    return self._n_bitarray_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_bitarray_to_raw"><code class="name">var <span class="ident">n_bitarray_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_bitarray_to_raw(self):
    return self._n_bitarray_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_bitarray"><code class="name">var <span class="ident">n_compressed_to_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_bitarray(self):
    return self._n_compressed_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_integer"><code class="name">var <span class="ident">n_compressed_to_integer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_integer(self):
    return self._n_compressed_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_compressed_to_raw"><code class="name">var <span class="ident">n_compressed_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_compressed_to_raw(self):
    return self._n_compressed_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_integer_to_compressed"><code class="name">var <span class="ident">n_integer_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_integer_to_compressed(self):
    return self._n_integer_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_integer_to_raw"><code class="name">var <span class="ident">n_integer_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_integer_to_raw(self):
    return self._n_integer_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_bitarray"><code class="name">var <span class="ident">n_raw_to_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_bitarray(self):
    return self._n_raw_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_compressed"><code class="name">var <span class="ident">n_raw_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_compressed(self):
    return self._n_raw_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_raw_to_integer"><code class="name">var <span class="ident">n_raw_to_integer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_raw_to_integer(self):
    return self._n_raw_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_read"><code class="name">var <span class="ident">n_read</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_read(self):
    return self._n_read</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.n_written"><code class="name">var <span class="ident">n_written</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_written(self):
    return self._n_written</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.nones"><code class="name">var <span class="ident">nones</span> :int</code></dt>
<dd>
<div class="desc"><p>self._nones might not be set since it can only be set at object creation if the full array was given</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nones(self) -&gt; int:
    &#34;&#34;&#34;self._nones might not be set since it can only be set at object creation if the full array was given&#34;&#34;&#34;
    if self._nones is None:
        _ = self.raw  # calling raw will compute nones and ones

    if self._coverage is None:
        self._coverage = self._nones / self.length
    return self._nones</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.ones"><code class="name">var <span class="ident">ones</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Contrary to other @properties, do not store 'ones' in array. Since it is the list of indexes where the
vector is one, 'ones' can be big : several MB or more.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ones(self) -&gt; np.ndarray:
    &#34;&#34;&#34; Contrary to other @properties, do not store &#39;ones&#39; in array. Since it is the list of indexes where the
    vector is one, &#39;ones&#39; can be big : several MB or more. &#34;&#34;&#34;
    raw = self.raw
    ones = np.where(raw == 1)[0].tolist()
    return ones</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.raw"><code class="name">var <span class="ident">raw</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the raw np.array. Will set relevant sizes if this has not been done yet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def raw(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the raw np.array. Will set relevant sizes if this has not been done yet&#34;&#34;&#34;
    if self.data_format == &#34;bitarray&#34;:
        return self._bitarray_to_raw()
    elif self.data_format == &#34;integer&#34;:
        return self._integer_to_raw()
    elif self.data_format == &#34;file&#34;:
        return self._read(out=False)
    elif &#34;compressed&#34; in self.data_format:
        return self._decompress()
    else:
        raise ValueError(f&#34;Unkown activation format {self.data_format}&#34;)</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.rel_entropy"><code class="name">var <span class="ident">rel_entropy</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rel_entropy(self) -&gt; float:
    if self._rel_entropy is None:
        _ = self.entropy  # will set self._rel_entropy
    return self._rel_entropy</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_bitarray"><code class="name">var <span class="ident">sizeof_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_bitarray(self):
    if self._sizeof_bitarray == -1 and Activation.FORCE_STAT:
        _ = self.as_bitarray
    return self._sizeof_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_compressed_array"><code class="name">var <span class="ident">sizeof_compressed_array</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_compressed_array(self):
    if self._sizeof_compressed_array == -1 and Activation.FORCE_STAT:
        _ = self.as_compressed_array
    return self._sizeof_compressed_array</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_compressed_str"><code class="name">var <span class="ident">sizeof_compressed_str</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_compressed_str(self):
    if self._sizeof_compressed_str == -1 and Activation.FORCE_STAT:
        _ = self.as_compressed_str
    return self._sizeof_compressed_str</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_file"><code class="name">var <span class="ident">sizeof_file</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_file(self):  # Can not force stat for file
    return self._sizeof_file</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_integer"><code class="name">var <span class="ident">sizeof_integer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_integer(self):
    if self._sizeof_integer == -1 and Activation.FORCE_STAT:
        _ = self.as_integer
    return self._sizeof_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_path"><code class="name">var <span class="ident">sizeof_path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_path(self):  # Can not force stat for file
    return self._sizeof_path</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.sizeof_raw"><code class="name">var <span class="ident">sizeof_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sizeof_raw(self):
    if self._sizeof_raw == -1 and Activation.FORCE_STAT:
        _ = self.raw
    return self._sizeof_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_bitarray_to_compressed"><code class="name">var <span class="ident">time_bitarray_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bitarray_to_compressed(self):
    if self._time_bitarray_to_compressed == -1 and Activation.FORCE_STAT:
        b = self.as_bitarray
        t0 = time()
        _ = self._compress(b)
        self._time_bitarray_to_compressed = time() - t0
        self._n_bitarray_to_compressed += 1
    return self._time_bitarray_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_bitarray_to_raw"><code class="name">var <span class="ident">time_bitarray_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bitarray_to_raw(self):
    if self._time_bitarray_to_raw == -1 and Activation.FORCE_STAT:
        _ = self._bitarray_to_raw(self.as_bitarray, out=False)
    return self._time_bitarray_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_compressed_to_bitarray"><code class="name">var <span class="ident">time_compressed_to_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_compressed_to_bitarray(self):
    if self._time_compressed_to_bitarray == -1 and Activation.FORCE_STAT:
        _ = self._decompress(self.as_bitarray, raw=False)
    return self._time_compressed_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_compressed_to_raw"><code class="name">var <span class="ident">time_compressed_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_compressed_to_raw(self):
    if self._time_compressed_to_raw == -1 and Activation.FORCE_STAT:
        _ = self._decompress(self.as_compressed, out=False)
    return self._time_compressed_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_integer_to_compressed"><code class="name">var <span class="ident">time_integer_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_integer_to_compressed(self):
    if self._time_integer_to_compressed == -1 and Activation.FORCE_STAT:
        i = self.as_integer
        t0 = time()
        _ = self._compress(i)
        self._time_integer_to_compressed = time() - t0
        self._n_integer_to_compressed += 1
    return self._time_integer_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_integer_to_raw"><code class="name">var <span class="ident">time_integer_to_raw</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_integer_to_raw(self):
    if self._time_integer_to_raw == -1 and Activation.FORCE_STAT:
        _ = self._integer_to_raw(self.as_integer, out=False)
    return self._time_integer_to_raw</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_bitarray"><code class="name">var <span class="ident">time_raw_to_bitarray</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_bitarray(self):
    if self._time_raw_to_bitarray == -1 and Activation.FORCE_STAT:
        t0 = time()
        _ = self._raw_to_bitarray(self.raw)
        self._time_raw_to_bitarray = time() - t0
        self._n_raw_to_bitarray += 1
    return self._time_raw_to_bitarray</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_compressed"><code class="name">var <span class="ident">time_raw_to_compressed</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_compressed(self):
    if self._time_raw_to_compressed == -1 and Activation.FORCE_STAT:
        t0 = time()
        _ = self._compress(self.raw)
        self._time_raw_to_compressed = time() - t0
        self._n_raw_to_compressed += 1
    return self._time_raw_to_compressed</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_raw_to_integer"><code class="name">var <span class="ident">time_raw_to_integer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_raw_to_integer(self):
    if self._time_raw_to_integer == -1 and Activation.FORCE_STAT:
        t0 = time()
        _ = self._raw_to_integer(self.raw)
        self._time_raw_to_integer = time() - t0
        self._n_raw_to_integer += 1
    return self._time_raw_to_integer</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_read"><code class="name">var <span class="ident">time_read</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_read(self):  # Can not force read : file might not exist
    return self._time_read</code></pre>
</details>
</dd>
<dt id="ruleskit.activation.Activation.time_write"><code class="name">var <span class="ident">time_write</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_write(self):  # Can not force write : would need to provide a name
    return self._time_write</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.activation.Activation.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the activation vector's data, either by deleting the local file or by calling del on self.data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Deletes the activation vector&#39;s data, either by deleting the local file or by calling del on self.data&#34;&#34;&#34;
    if self.data_format == &#34;file&#34;:
        if self.data.is_file():
            self.data.unlink()
    else:
        del self.data
        self.data = None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.activation.Activation" href="#ruleskit.activation.Activation">Activation</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.activation.Activation.DEFAULT_TEMPDIR" href="#ruleskit.activation.Activation.DEFAULT_TEMPDIR">DEFAULT_TEMPDIR</a></code></li>
<li><code><a title="ruleskit.activation.Activation.DTYPE" href="#ruleskit.activation.Activation.DTYPE">DTYPE</a></code></li>
<li><code><a title="ruleskit.activation.Activation.FORCE_STAT" href="#ruleskit.activation.Activation.FORCE_STAT">FORCE_STAT</a></code></li>
<li><code><a title="ruleskit.activation.Activation.WILL_COMPARE" href="#ruleskit.activation.Activation.WILL_COMPARE">WILL_COMPARE</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_bitarray" href="#ruleskit.activation.Activation.as_bitarray">as_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed" href="#ruleskit.activation.Activation.as_compressed">as_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed_array" href="#ruleskit.activation.Activation.as_compressed_array">as_compressed_array</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_compressed_str" href="#ruleskit.activation.Activation.as_compressed_str">as_compressed_str</a></code></li>
<li><code><a title="ruleskit.activation.Activation.as_integer" href="#ruleskit.activation.Activation.as_integer">as_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.clean_files" href="#ruleskit.activation.Activation.clean_files">clean_files</a></code></li>
<li><code><a title="ruleskit.activation.Activation.coverage" href="#ruleskit.activation.Activation.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.activation.Activation.delete" href="#ruleskit.activation.Activation.delete">delete</a></code></li>
<li><code><a title="ruleskit.activation.Activation.entropy" href="#ruleskit.activation.Activation.entropy">entropy</a></code></li>
<li><code><a title="ruleskit.activation.Activation.multi_logical_and" href="#ruleskit.activation.Activation.multi_logical_and">multi_logical_and</a></code></li>
<li><code><a title="ruleskit.activation.Activation.multi_logical_or" href="#ruleskit.activation.Activation.multi_logical_or">multi_logical_or</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_bitarray_to_compressed" href="#ruleskit.activation.Activation.n_bitarray_to_compressed">n_bitarray_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_bitarray_to_raw" href="#ruleskit.activation.Activation.n_bitarray_to_raw">n_bitarray_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_bitarray" href="#ruleskit.activation.Activation.n_compressed_to_bitarray">n_compressed_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_integer" href="#ruleskit.activation.Activation.n_compressed_to_integer">n_compressed_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_compressed_to_raw" href="#ruleskit.activation.Activation.n_compressed_to_raw">n_compressed_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_integer_to_compressed" href="#ruleskit.activation.Activation.n_integer_to_compressed">n_integer_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_integer_to_raw" href="#ruleskit.activation.Activation.n_integer_to_raw">n_integer_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_bitarray" href="#ruleskit.activation.Activation.n_raw_to_bitarray">n_raw_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_compressed" href="#ruleskit.activation.Activation.n_raw_to_compressed">n_raw_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_raw_to_integer" href="#ruleskit.activation.Activation.n_raw_to_integer">n_raw_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_read" href="#ruleskit.activation.Activation.n_read">n_read</a></code></li>
<li><code><a title="ruleskit.activation.Activation.n_written" href="#ruleskit.activation.Activation.n_written">n_written</a></code></li>
<li><code><a title="ruleskit.activation.Activation.nones" href="#ruleskit.activation.Activation.nones">nones</a></code></li>
<li><code><a title="ruleskit.activation.Activation.ones" href="#ruleskit.activation.Activation.ones">ones</a></code></li>
<li><code><a title="ruleskit.activation.Activation.raw" href="#ruleskit.activation.Activation.raw">raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.rel_entropy" href="#ruleskit.activation.Activation.rel_entropy">rel_entropy</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_bitarray" href="#ruleskit.activation.Activation.sizeof_bitarray">sizeof_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_compressed_array" href="#ruleskit.activation.Activation.sizeof_compressed_array">sizeof_compressed_array</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_compressed_str" href="#ruleskit.activation.Activation.sizeof_compressed_str">sizeof_compressed_str</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_file" href="#ruleskit.activation.Activation.sizeof_file">sizeof_file</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_integer" href="#ruleskit.activation.Activation.sizeof_integer">sizeof_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_path" href="#ruleskit.activation.Activation.sizeof_path">sizeof_path</a></code></li>
<li><code><a title="ruleskit.activation.Activation.sizeof_raw" href="#ruleskit.activation.Activation.sizeof_raw">sizeof_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_bitarray_to_compressed" href="#ruleskit.activation.Activation.time_bitarray_to_compressed">time_bitarray_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_bitarray_to_raw" href="#ruleskit.activation.Activation.time_bitarray_to_raw">time_bitarray_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_compressed_to_bitarray" href="#ruleskit.activation.Activation.time_compressed_to_bitarray">time_compressed_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_compressed_to_raw" href="#ruleskit.activation.Activation.time_compressed_to_raw">time_compressed_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_integer_to_compressed" href="#ruleskit.activation.Activation.time_integer_to_compressed">time_integer_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_integer_to_raw" href="#ruleskit.activation.Activation.time_integer_to_raw">time_integer_to_raw</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_bitarray" href="#ruleskit.activation.Activation.time_raw_to_bitarray">time_raw_to_bitarray</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_compressed" href="#ruleskit.activation.Activation.time_raw_to_compressed">time_raw_to_compressed</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_raw_to_integer" href="#ruleskit.activation.Activation.time_raw_to_integer">time_raw_to_integer</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_read" href="#ruleskit.activation.Activation.time_read">time_read</a></code></li>
<li><code><a title="ruleskit.activation.Activation.time_write" href="#ruleskit.activation.Activation.time_write">time_write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>