<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ruleskit.rule API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.rule</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
import numpy as np
from typing import Optional, Union
from time import time
from .condition import Condition
from .activation import Activation
from .utils import rfunctions as functions


class Rule(ABC):
    LOCAL_ACTIVATION = False

    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)

        self._condition = condition
        self._activation = activation
        self._prediction = None

        self._time_fit = -1
        self._time_calc_activation = -1
        self._time_predict = -1

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        condition = self._condition + other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return NotImplemented(&#34;Can not add rules (seen as &#39;logical OR&#39;). you can use logical AND however.&#34;)

    # def __del__(self):
    #     self.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    @property
    def activation_available(self):
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def condition(self) -&gt; Condition:
        return self._condition

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def coverage(self) -&gt; Union[None, float]:
        if self._activation:
            return self._activation.coverage
        return None

    @property
    def prediction(self) -&gt; float:
        return self._prediction

    @property
    def time_fit(self):
        return self._time_fit

    @property
    def time_predict(self):
        return self._time_predict

    @property
    def time_calc_activation(self):
        return self._time_calc_activation

    def __eq__(self, other) -&gt; bool:
        if not isinstance(other, Rule):
            return False
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        if not self._activation or not other._activation:
            return False
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    @property
    def to_hash(self):
        return (&#34;r&#34;,) + self._condition.to_hash[1:]

    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    def __len__(self):
        return len(self._condition)

    def evaluate(self, xs: np.ndarray) -&gt; Activation:
        arr = self._condition.evaluate(xs)
        # noinspection PyTypeChecker
        a = Activation(arr, to_file=Rule.LOCAL_ACTIVATION)
        return a

    # noinspection PyUnusedLocal
    def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;, **kwargs):
        &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
        t0 = time()
        self.calc_activation(xs)  # returns Activation
        self.calc_attributes(xs, y, **kwargs)
        self._time_fit = time() - t0

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, **kwargs):
        &#34;&#34;&#34;Implement in daughter class&#34;&#34;&#34;
        pass

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        t0 = time()
        self._activation = self.evaluate(xs)
        self._time_calc_activation = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = self._prediction * self.activation
        self._time_predict = time() - t0
        return to_ret


class RegressionRule(Rule):
    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)

        self._coverage = None
        self._std = None
        self._criterion = None

        # Inspection / Audit attributs
        self._time_calc_criterion = -1
        self._time_calc_prediction = -1
        self._time_calc_std = -1

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    @property
    def time_calc_prediction(self):
        return self._time_calc_prediction

    @property
    def time_calc_criterion(self):
        return self._time_calc_criterion

    @property
    def time_calc_std(self):
        return self._time_calc_std

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;, **kwargs):
        self.calc_activation(xs)
        self.calc_prediction(y)
        self.calc_std(y)
        prediction_vector = self.prediction * self.activation
        self.calc_criterion(prediction_vector, y, crit)

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        t0 = time()
        self._activation = self.evaluate(xs)
        self._time_calc_activation = time() - t0

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            return None
        self._prediction = functions.conditional_mean(self.activation, y)
        self._time_calc_prediction = time() - t0

    def calc_std(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            return None
        self._std = functions.conditional_std(self.activation, y)
        self._time_calc_std = time() - t0

    def calc_criterion(self, p, y, c, **kwargs):
        t0 = time()
        self._criterion = functions.calc_regression_criterion(p, y, c)
        self._time_calc_criterion = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = self._prediction * self.activation
        self._time_predict = time() - t0
        return to_ret


class ClassificationRule(Rule):
    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)

        self._criterion = None

        # Inspection / Audit attributs
        self._time_calc_criterion = -1
        self._time_calc_prediction = -1

    @property
    def prediction(self) -&gt; Union[int, str, None]:
        if self._prediction is not None:
            prop = [p[1] for p in self._prediction]
            idx = prop.index(max(prop))
            return self._prediction[idx][0]
        else:
            return None

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;success_rate&#34;, **kwargs):
        self.calc_prediction(y)
        self.calc_criterion(y, crit)

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.most_common_class(self.activation, y)
        self._time_calc_prediction = time() - t0

    def calc_criterion(self, y, c):
        t0 = time()
        self._criterion = functions.calc_classification_criterion(self.activation, self.prediction, y, c)
        self._time_calc_criterion = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = np.array([self.prediction if i == 1 else &#34;&#34; for i in self.activation])
        self._time_predict = time() - t0
        return to_ret</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.rule.ClassificationRule"><code class="flex name class">
<span>class <span class="ident">ClassificationRule</span></span>
<span>(</span><span>condition: Union[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>, NoneType] = None, activation: Union[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassificationRule(Rule):
    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)

        self._criterion = None

        # Inspection / Audit attributs
        self._time_calc_criterion = -1
        self._time_calc_prediction = -1

    @property
    def prediction(self) -&gt; Union[int, str, None]:
        if self._prediction is not None:
            prop = [p[1] for p in self._prediction]
            idx = prop.index(max(prop))
            return self._prediction[idx][0]
        else:
            return None

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;success_rate&#34;, **kwargs):
        self.calc_prediction(y)
        self.calc_criterion(y, crit)

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
        self._prediction = functions.most_common_class(self.activation, y)
        self._time_calc_prediction = time() - t0

    def calc_criterion(self, y, c):
        t0 = time()
        self._criterion = functions.calc_classification_criterion(self.activation, self.prediction, y, c)
        self._time_calc_criterion = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = np.array([self.prediction if i == 1 else &#34;&#34; for i in self.activation])
        self._time_predict = time() - t0
        return to_ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.ClassificationRule.criterion"><code class="name">var <span class="ident">criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def criterion(self) -&gt; float:
    return self._criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.ClassificationRule.prediction"><code class="name">var <span class="ident">prediction</span> : Union[int, str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prediction(self) -&gt; Union[int, str, None]:
    if self._prediction is not None:
        prop = [p[1] for p in self._prediction]
        idx = prop.index(max(prop))
        return self._prediction[idx][0]
    else:
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.ClassificationRule.calc_criterion"><code class="name flex">
<span>def <span class="ident">calc_criterion</span></span>(<span>self, y, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_criterion(self, y, c):
    t0 = time()
    self._criterion = functions.calc_classification_criterion(self.activation, self.prediction, y, c)
    self._time_calc_criterion = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.ClassificationRule.calc_prediction"><code class="name flex">
<span>def <span class="ident">calc_prediction</span></span>(<span>self, y: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not need to to all 'fit' but only want to compute 'prediction'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction(self, y: np.ndarray) -&gt; None:
    &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
    t0 = time()
    if self.activation is None:
        raise ValueError(&#34;The activation vector has not been computed yet.&#34;)
    self._prediction = functions.most_common_class(self.activation, y)
    self._time_calc_prediction = time() - t0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_attributes" href="#ruleskit.rule.Rule.calc_attributes">calc_attributes</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ruleskit.rule.RegressionRule"><code class="flex name class">
<span>class <span class="ident">RegressionRule</span></span>
<span>(</span><span>condition: Union[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>, NoneType] = None, activation: Union[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegressionRule(Rule):
    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):
        super().__init__(condition, activation)

        self._coverage = None
        self._std = None
        self._criterion = None

        # Inspection / Audit attributs
        self._time_calc_criterion = -1
        self._time_calc_prediction = -1
        self._time_calc_std = -1

    @property
    def std(self) -&gt; float:
        return self._std

    @property
    def criterion(self) -&gt; float:
        return self._criterion

    @property
    def time_calc_prediction(self):
        return self._time_calc_prediction

    @property
    def time_calc_criterion(self):
        return self._time_calc_criterion

    @property
    def time_calc_std(self):
        return self._time_calc_std

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;, **kwargs):
        self.calc_activation(xs)
        self.calc_prediction(y)
        self.calc_std(y)
        prediction_vector = self.prediction * self.activation
        self.calc_criterion(prediction_vector, y, crit)

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        t0 = time()
        self._activation = self.evaluate(xs)
        self._time_calc_activation = time() - t0

    def calc_prediction(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            return None
        self._prediction = functions.conditional_mean(self.activation, y)
        self._time_calc_prediction = time() - t0

    def calc_std(self, y: np.ndarray) -&gt; None:
        &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
        t0 = time()
        if self.activation is None:
            return None
        self._std = functions.conditional_std(self.activation, y)
        self._time_calc_std = time() - t0

    def calc_criterion(self, p, y, c, **kwargs):
        t0 = time()
        self._criterion = functions.calc_regression_criterion(p, y, c)
        self._time_calc_criterion = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = self._prediction * self.activation
        self._time_predict = time() - t0
        return to_ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.RegressionRule.criterion"><code class="name">var <span class="ident">criterion</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def criterion(self) -&gt; float:
    return self._criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.std"><code class="name">var <span class="ident">std</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self) -&gt; float:
    return self._std</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_criterion"><code class="name">var <span class="ident">time_calc_criterion</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_criterion(self):
    return self._time_calc_criterion</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_prediction"><code class="name">var <span class="ident">time_calc_prediction</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_prediction(self):
    return self._time_calc_prediction</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.time_calc_std"><code class="name">var <span class="ident">time_calc_std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_std(self):
    return self._time_calc_std</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.RegressionRule.calc_activation"><code class="name flex">
<span>def <span class="ident">calc_activation</span></span>(<span>self, xs: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_activation(self, xs: np.ndarray) -&gt; None:
    t0 = time()
    self._activation = self.evaluate(xs)
    self._time_calc_activation = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_criterion"><code class="name flex">
<span>def <span class="ident">calc_criterion</span></span>(<span>self, p, y, c, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_criterion(self, p, y, c, **kwargs):
    t0 = time()
    self._criterion = functions.calc_regression_criterion(p, y, c)
    self._time_calc_criterion = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_prediction"><code class="name flex">
<span>def <span class="ident">calc_prediction</span></span>(<span>self, y: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not need to to all 'fit' but only want to compute 'prediction'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_prediction(self, y: np.ndarray) -&gt; None:
    &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;prediction&#39;&#34;&#34;&#34;
    t0 = time()
    if self.activation is None:
        return None
    self._prediction = functions.conditional_mean(self.activation, y)
    self._time_calc_prediction = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.RegressionRule.calc_std"><code class="name flex">
<span>def <span class="ident">calc_std</span></span>(<span>self, y: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If you do not need to to all 'fit' but only want to compute 'std'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_std(self, y: np.ndarray) -&gt; None:
    &#34;&#34;&#34;If you do not need to to all &#39;fit&#39; but only want to compute &#39;std&#39;&#34;&#34;&#34;
    t0 = time()
    if self.activation is None:
        return None
    self._std = functions.conditional_std(self.activation, y)
    self._time_calc_std = time() - t0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_attributes" href="#ruleskit.rule.Rule.calc_attributes">calc_attributes</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ruleskit.rule.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>condition: Union[<a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a>, NoneType] = None, activation: Union[<a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a>, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(ABC):
    LOCAL_ACTIVATION = False

    def __init__(
        self, condition: Optional[Condition] = None, activation: Optional[Activation] = None,
    ):

        if condition is not None and not isinstance(condition, Condition):
            raise TypeError(&#34;Argument &#39;condition&#39; must derive from Condition or be None.&#34;)
        if activation is not None and not isinstance(activation, Activation):
            raise TypeError(&#34;Argument &#39;activation&#39; must derive from Activation or be None.&#34;)

        self._condition = condition
        self._activation = activation
        self._prediction = None

        self._time_fit = -1
        self._time_calc_activation = -1
        self._time_predict = -1

    def __and__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        condition = self._condition + other._condition
        activation = self._activation &amp; other._activation
        return self.__class__(condition, activation)

    def __add__(self, other: &#34;Rule&#34;) -&gt; &#34;Rule&#34;:
        return NotImplemented(&#34;Can not add rules (seen as &#39;logical OR&#39;). you can use logical AND however.&#34;)

    # def __del__(self):
    #     self.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    @property
    def activation_available(self):
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def condition(self) -&gt; Condition:
        return self._condition

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def coverage(self) -&gt; Union[None, float]:
        if self._activation:
            return self._activation.coverage
        return None

    @property
    def prediction(self) -&gt; float:
        return self._prediction

    @property
    def time_fit(self):
        return self._time_fit

    @property
    def time_predict(self):
        return self._time_predict

    @property
    def time_calc_activation(self):
        return self._time_calc_activation

    def __eq__(self, other) -&gt; bool:
        if not isinstance(other, Rule):
            return False
        else:
            return self._condition == other._condition

    def __contains__(self, other: &#34;Rule&#34;) -&gt; bool:
        if not self._activation or not other._activation:
            return False
        return other._activation in self._activation

    def __str__(self) -&gt; str:
        prediction = &#34;&lt;prediction unset&gt;&#34;
        if self._prediction is not None:
            prediction = self._prediction
        if self._condition is None:
            return &#34;empty rule&#34;
        return f&#34;If {self._condition.__str__()} Then {prediction}.&#34;

    @property
    def to_hash(self):
        return (&#34;r&#34;,) + self._condition.to_hash[1:]

    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    def __len__(self):
        return len(self._condition)

    def evaluate(self, xs: np.ndarray) -&gt; Activation:
        arr = self._condition.evaluate(xs)
        # noinspection PyTypeChecker
        a = Activation(arr, to_file=Rule.LOCAL_ACTIVATION)
        return a

    # noinspection PyUnusedLocal
    def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;, **kwargs):
        &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
        t0 = time()
        self.calc_activation(xs)  # returns Activation
        self.calc_attributes(xs, y, **kwargs)
        self._time_fit = time() - t0

    def calc_attributes(self, xs: np.ndarray, y: np.ndarray, **kwargs):
        &#34;&#34;&#34;Implement in daughter class&#34;&#34;&#34;
        pass

    def calc_activation(self, xs: np.ndarray) -&gt; None:
        t0 = time()
        self._activation = self.evaluate(xs)
        self._time_calc_activation = time() - t0

    def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
        Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
        t0 = time()
        if xs is not None:
            self.calc_activation(xs)
        elif self.activation is None:
            raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
        to_ret = self._prediction * self.activation
        self._time_predict = time() - t0
        return to_ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ruleskit.rule.ClassificationRule" href="#ruleskit.rule.ClassificationRule">ClassificationRule</a></li>
<li><a title="ruleskit.rule.RegressionRule" href="#ruleskit.rule.RegressionRule">RegressionRule</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.rule.Rule.LOCAL_ACTIVATION"><code class="name">var <span class="ident">LOCAL_ACTIVATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.rule.Rule.activation"><code class="name">var <span class="ident">activation</span> : Union[NoneType, numpy.ndarray]</code></dt>
<dd>
<div class="desc"><p>Decompress activation vector</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation(self) -&gt; Union[None, np.ndarray]:
    &#34;&#34;&#34;Decompress activation vector

    Returns
    -------
    np.ndarray
        of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
    &#34;&#34;&#34;
    if self._activation:
        return self._activation.raw
    return None</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.activation_available"><code class="name">var <span class="ident">activation_available</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation_available(self):
    if self._activation is None:
        return False
    if self._activation.data_format == &#34;file&#34;:
        return self._activation.data.is_file()
    else:
        return self._activation.data is not None</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.condition"><code class="name">var <span class="ident">condition</span> : <a title="ruleskit.condition.Condition" href="condition.html#ruleskit.condition.Condition">Condition</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition(self) -&gt; Condition:
    return self._condition</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.coverage"><code class="name">var <span class="ident">coverage</span> : Union[NoneType, float]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; Union[None, float]:
    if self._activation:
        return self._activation.coverage
    return None</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.prediction"><code class="name">var <span class="ident">prediction</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prediction(self) -&gt; float:
    return self._prediction</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_calc_activation"><code class="name">var <span class="ident">time_calc_activation</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_calc_activation(self):
    return self._time_calc_activation</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_fit"><code class="name">var <span class="ident">time_fit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_fit(self):
    return self._time_fit</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.time_predict"><code class="name">var <span class="ident">time_predict</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_predict(self):
    return self._time_predict</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.to_hash"><code class="name">var <span class="ident">to_hash</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_hash(self):
    return (&#34;r&#34;,) + self._condition.to_hash[1:]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.rule.Rule.calc_activation"><code class="name flex">
<span>def <span class="ident">calc_activation</span></span>(<span>self, xs: numpy.ndarray) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_activation(self, xs: np.ndarray) -&gt; None:
    t0 = time()
    self._activation = self.evaluate(xs)
    self._time_calc_activation = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.calc_attributes"><code class="name flex">
<span>def <span class="ident">calc_attributes</span></span>(<span>self, xs: numpy.ndarray, y: numpy.ndarray, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement in daughter class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_attributes(self, xs: np.ndarray, y: np.ndarray, **kwargs):
    &#34;&#34;&#34;Implement in daughter class&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.del_activation"><code class="name flex">
<span>def <span class="ident">del_activation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the activation vector's data, but not the object itself, so any computed attribute will remain
available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_activation(self):
    &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
    available&#34;&#34;&#34;
    if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
        self._activation.delete()</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, xs: numpy.ndarray) ‑> <a title="ruleskit.activation.Activation" href="activation.html#ruleskit.activation.Activation">Activation</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, xs: np.ndarray) -&gt; Activation:
    arr = self._condition.evaluate(xs)
    # noinspection PyTypeChecker
    a = Activation(arr, to_file=Rule.LOCAL_ACTIVATION)
    return a</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, xs: numpy.ndarray, y: numpy.ndarray, crit: str = 'mse', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes activation, prediction, std and criteria of the rule for a given xs and y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, xs: np.ndarray, y: np.ndarray, crit: str = &#34;mse&#34;, **kwargs):
    &#34;&#34;&#34;Computes activation, prediction, std and criteria of the rule for a given xs and y.&#34;&#34;&#34;
    t0 = time()
    self.calc_activation(xs)  # returns Activation
    self.calc_attributes(xs, y, **kwargs)
    self._time_fit = time() - t0</code></pre>
</details>
</dd>
<dt id="ruleskit.rule.Rule.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, xs: Union[numpy.ndarray, NoneType] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the prediction vector. If xs is not given, will use existing activation vector.
Will raise ValueError is xs is None and activation is not yet known.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, xs: Optional[np.ndarray] = None) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the prediction vector. If xs is not given, will use existing activation vector.
    Will raise ValueError is xs is None and activation is not yet known.&#34;&#34;&#34;
    t0 = time()
    if xs is not None:
        self.calc_activation(xs)
    elif self.activation is None:
        raise ValueError(&#34;If the activation vector has not been computed yet, xs can not be None.&#34;)
    to_ret = self._prediction * self.activation
    self._time_predict = time() - t0
    return to_ret</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.rule.ClassificationRule" href="#ruleskit.rule.ClassificationRule">ClassificationRule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.ClassificationRule.calc_criterion" href="#ruleskit.rule.ClassificationRule.calc_criterion">calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.calc_prediction" href="#ruleskit.rule.ClassificationRule.calc_prediction">calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.criterion" href="#ruleskit.rule.ClassificationRule.criterion">criterion</a></code></li>
<li><code><a title="ruleskit.rule.ClassificationRule.prediction" href="#ruleskit.rule.ClassificationRule.prediction">prediction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ruleskit.rule.RegressionRule" href="#ruleskit.rule.RegressionRule">RegressionRule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.RegressionRule.calc_activation" href="#ruleskit.rule.RegressionRule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_criterion" href="#ruleskit.rule.RegressionRule.calc_criterion">calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_prediction" href="#ruleskit.rule.RegressionRule.calc_prediction">calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.calc_std" href="#ruleskit.rule.RegressionRule.calc_std">calc_std</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.criterion" href="#ruleskit.rule.RegressionRule.criterion">criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.std" href="#ruleskit.rule.RegressionRule.std">std</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_criterion" href="#ruleskit.rule.RegressionRule.time_calc_criterion">time_calc_criterion</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_prediction" href="#ruleskit.rule.RegressionRule.time_calc_prediction">time_calc_prediction</a></code></li>
<li><code><a title="ruleskit.rule.RegressionRule.time_calc_std" href="#ruleskit.rule.RegressionRule.time_calc_std">time_calc_std</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ruleskit.rule.Rule" href="#ruleskit.rule.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.rule.Rule.LOCAL_ACTIVATION" href="#ruleskit.rule.Rule.LOCAL_ACTIVATION">LOCAL_ACTIVATION</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation" href="#ruleskit.rule.Rule.activation">activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.activation_available" href="#ruleskit.rule.Rule.activation_available">activation_available</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_activation" href="#ruleskit.rule.Rule.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.calc_attributes" href="#ruleskit.rule.Rule.calc_attributes">calc_attributes</a></code></li>
<li><code><a title="ruleskit.rule.Rule.condition" href="#ruleskit.rule.Rule.condition">condition</a></code></li>
<li><code><a title="ruleskit.rule.Rule.coverage" href="#ruleskit.rule.Rule.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.rule.Rule.del_activation" href="#ruleskit.rule.Rule.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.evaluate" href="#ruleskit.rule.Rule.evaluate">evaluate</a></code></li>
<li><code><a title="ruleskit.rule.Rule.fit" href="#ruleskit.rule.Rule.fit">fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.predict" href="#ruleskit.rule.Rule.predict">predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.prediction" href="#ruleskit.rule.Rule.prediction">prediction</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_calc_activation" href="#ruleskit.rule.Rule.time_calc_activation">time_calc_activation</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_fit" href="#ruleskit.rule.Rule.time_fit">time_fit</a></code></li>
<li><code><a title="ruleskit.rule.Rule.time_predict" href="#ruleskit.rule.Rule.time_predict">time_predict</a></code></li>
<li><code><a title="ruleskit.rule.Rule.to_hash" href="#ruleskit.rule.Rule.to_hash">to_hash</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>