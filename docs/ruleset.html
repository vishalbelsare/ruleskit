<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ruleskit.ruleset API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ruleskit.ruleset</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
import operator
import pandas as pd
from typing import List, Union
from functools import reduce
from collections import Counter
import numpy as np
from collections import OrderedDict
from .rule import Rule
from .condition import HyperrectangleCondition
from .activation import Activation


class RuleSet(ABC):

    NLINES = 5

    def __init__(
        self,
        rules_list: Union[List[Rule], None] = None,
        remember_activation: bool = True,
        stack_activation: bool = False,
    ):
        self._rules = []
        self._activation = None
        self.stacked_activations = None
        self.remember_activation = remember_activation
        self.stack_activation = stack_activation
        if rules_list is not None:
            for rule in rules_list:
                if not isinstance(rule, Rule) and rule is not None:
                    raise TypeError(f&#34;Some rules in given iterable were not of type &#39;Rule&#39; but of type {type(rule)}&#34;)
                if rule is not None:
                    self.append(rule, update_activation=False)
                if self.remember_activation:
                    self.compute_self_activation()
                if self.stack_activation:
                    self.compute_stacked_activation()

    # noinspection PyProtectedMember,PyTypeChecker
    def __iadd__(self, other: Union[&#34;RuleSet&#34;, Rule]):
        if isinstance(other, Rule):
            self._rules.append(other)
        else:
            self._rules += other._rules
        if self.remember_activation:
            self._update_activation(other)
        if self.stack_activation:
            self._update_stacked_activation(other)
        return self

    def __add__(self, other: Union[&#34;RuleSet&#34;, Rule]):
        remember_activation = self.remember_activation
        stack_activation = self.stack_activation
        if isinstance(other, Rule):
            rules = self.rules + [other]
        else:
            remember_activation &amp;= other.remember_activation
            stack_activation &amp;= other.stack_activation
            rules = list(set(self.rules + other.rules))
        return self.__class__(rules, remember_activation=remember_activation, stack_activation=stack_activation)

    def __len__(self):
        return len(self.rules)

    def __eq__(self, other: &#34;RuleSet&#34;):
        return set(self.rules) == set(other.rules)

    def __iter__(self):
        if hasattr(self, &#34;_rules&#34;):
            return self.rules.__iter__()
        else:
            return [].__iter__()

    def __getitem__(self, key):
        if isinstance(key, slice):
            indices = range(*key.indices(len(self.rules)))
            return self.__class__([self.rules[i] for i in indices])
        return self.rules.__getitem__(key)

    def __str__(self):
        if len(self) &lt; 2 * RuleSet.NLINES:
            return &#34;\n&#34;.join([str(self[i]) for i in range(len(self))])
        else:
            return &#34;\n&#34;.join(
                [str(self[i]) for i in range(RuleSet.NLINES)]
                + [&#34;...&#34;]
                + [str(self[i]) for i in range(len(self) - RuleSet.NLINES, len(self))]
            )

    @property
    def to_hash(self):
        if len(self) == 0:
            return &#34;rs&#34;,
        to_hash = (&#34;rs&#34;,)
        for r in self:
            rule_hash = r.to_hash[1:]
            to_hash += rule_hash
        return to_hash

    # noinspection PyProtectedMember
    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    # noinspection PyProtectedMember,PyTypeChecker
    def _update_activation(self, other: Union[Rule, &#34;RuleSet&#34;]):
        if other.activation_available:
            if self._activation is None:
                self._activation = Activation(other.activation, to_file=Rule.LOCAL_ACTIVATION)
            else:
                self._activation = self._activation | other._activation

    # noinspection PyProtectedMember,PyTypeChecker
    def _update_stacked_activation(self, other: Union[Rule, &#34;RuleSet&#34;]):
        if other.activation_available:
            if self._activation is None:
                if isinstance(other, Rule):
                    self.stacked_activations = pd.DataFrame(data=np.array(other.activation).T, columns=[str(other)])
                else:
                    self.stacked_activations = other.stacked_activations
            else:
                if isinstance(other, Rule):
                    self.stacked_activations[str(other)] = other.activation
                else:
                    self.stacked_activations = pd.concat([self.stacked_activations, other.stacked_activations], axis=1)

    def compute_self_activation(self):
        if len(self) == 0:
            return
        activations_available = all([r.activation_available for r in self])
        if activations_available:
            # noinspection PyProtectedMember
            self._activation = Activation.multi_logical_or([r._activation for r in self])

    def compute_stacked_activation(self):
        if len(self) == 0:
            return
        activations_available = all([r.activation_available for r in self])
        if activations_available:
            # noinspection PyProtectedMember
            self.stacked_activations = pd.DataFrame(
                data=np.array([r.activation for r in self]).T, columns=[str(r.condition) for r in self]
            )

    # def __del__(self):
    #     self.del_activations()
    #     self.del_activation()

    def del_activations(self):
        for r in self:
            r.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    def del_stacked_activations(self):
        if hasattr(self, &#34;stacked_activations&#34;) and self.stacked_activations is not None:
            del self.stacked_activations
            self.stacked_activations = None

    def append(self, rule: Rule, update_activation: bool = True):
        if not isinstance(rule, Rule):
            raise TypeError(f&#34;RuleSet&#39;s append method expects a Rule object, got {type(rule)}&#34;)
        remember_activation = self.remember_activation
        stack_activation = self.stack_activation
        if not update_activation:
            self.remember_activation = False
            self.stack_activation = False
        self.__iadd__(rule)
        self.remember_activation = remember_activation
        self.stack_activation = stack_activation

    def sort(self, criterion: str = None, reverse: bool = False) -&gt; None:
        if len(self) == 0:
            return
        import ast

        if criterion is None or criterion == &#34;&#34;:
            if not (
                hasattr(self[0].condition, &#34;features_names&#34;)
                and hasattr(self[0].condition, &#34;bmins&#34;)
                and hasattr(self[0].condition, &#34;bmaxs&#34;)
            ):
                return
            # noinspection PyUnresolvedReferences
            fnames = list(set([str(r.features_names) for r in self]))
            dict_names = {}
            lmax = 1
            for f in fnames:
                l_ = len(ast.literal_eval(f))
                if l_ &gt; lmax:
                    lmax = l_
                if l_ not in dict_names:
                    dict_names[l_] = []
                dict_names[l_].append(f)
            for l_ in dict_names:
                dict_names[l_].sort(reverse=reverse)
            fnames = []
            for l_ in range(1, lmax + 1):
                if l_ in dict_names:
                    fnames += dict_names[l_]

            rules_by_fnames = OrderedDict({f: [] for f in fnames})
            for rule in self:
                # noinspection PyUnresolvedReferences
                v = str(rule.features_names)
                rules_by_fnames[v].append(rule)
            rules_by_fnames = {
                n: sorted(rules_by_fnames[n], key=lambda x: x.condition.bmins + x.condition.bmaxs)
                for n in rules_by_fnames
            }
            self._rules = []
            for n in rules_by_fnames:
                self._rules += rules_by_fnames[n]
        elif hasattr(self[0], criterion):
            self._rules = sorted(self, key=lambda x: getattr(x, criterion), reverse=reverse)
        else:
            raise ValueError(f&#34;Can not sort RuleSet according to criterion {criterion}&#34;)
        if self.stack_activation:
            self.stacked_activations = self.stacked_activations[[str(r.condition) for r in self]]

    @property
    def activation_available(self):
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def stacked_activations_available(self):
        if self.stack_activation is None:
            return False
        return True

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def rules(self) -&gt; List[Rule]:
        return self._rules

    def calc_activation(self, xs: np.ndarray):
        if len(self) == 0:
            raise ValueError(&#34;Can not use calc_activation : The ruleset is empty!&#34;)
        [rule.calc_activation(xs) for rule in self.rules]
        self._activation = None
        self.compute_self_activation()

    def calc_stacked_activations(self, xs: np.ndarray):
        if len(self) == 0:
            raise ValueError(&#34;Can not use calc_stacked_activations : The ruleset is empty!&#34;)
        [rule.calc_activation(xs) for rule in self.rules]
        self._activation = None
        self.compute_stacked_activation()

    @property
    def coverage(self) -&gt; float:
        if not self.activation_available:
            return 0.0
        else:
            return self._activation.coverage

    def get_variables_count(self):
        &#34;&#34;&#34;
        Get a counter of all different features in the ruleset
        Parameters
        ----------
        Return
        ------
        count : {Counter type}
            Counter of all different features in the ruleset
        &#34;&#34;&#34;
        # noinspection PyUnresolvedReferences
        var_in = [
            rule.condition.features_names
            if isinstance(rule.condition, HyperrectangleCondition)
            else rule.condition.features_indexes
            for rule in self
        ]
        if len(var_in) &gt; 1:
            var_in = reduce(operator.add, var_in)
        count = Counter(var_in)

        count = count.most_common()
        return count</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ruleskit.ruleset.RuleSet"><code class="flex name class">
<span>class <span class="ident">RuleSet</span></span>
<span>(</span><span>rules_list: Union[List[<a title="ruleskit.rule.Rule" href="rule.html#ruleskit.rule.Rule">Rule</a>], NoneType] = None, remember_activation: bool = True, stack_activation: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleSet(ABC):

    NLINES = 5

    def __init__(
        self,
        rules_list: Union[List[Rule], None] = None,
        remember_activation: bool = True,
        stack_activation: bool = False,
    ):
        self._rules = []
        self._activation = None
        self.stacked_activations = None
        self.remember_activation = remember_activation
        self.stack_activation = stack_activation
        if rules_list is not None:
            for rule in rules_list:
                if not isinstance(rule, Rule) and rule is not None:
                    raise TypeError(f&#34;Some rules in given iterable were not of type &#39;Rule&#39; but of type {type(rule)}&#34;)
                if rule is not None:
                    self.append(rule, update_activation=False)
                if self.remember_activation:
                    self.compute_self_activation()
                if self.stack_activation:
                    self.compute_stacked_activation()

    # noinspection PyProtectedMember,PyTypeChecker
    def __iadd__(self, other: Union[&#34;RuleSet&#34;, Rule]):
        if isinstance(other, Rule):
            self._rules.append(other)
        else:
            self._rules += other._rules
        if self.remember_activation:
            self._update_activation(other)
        if self.stack_activation:
            self._update_stacked_activation(other)
        return self

    def __add__(self, other: Union[&#34;RuleSet&#34;, Rule]):
        remember_activation = self.remember_activation
        stack_activation = self.stack_activation
        if isinstance(other, Rule):
            rules = self.rules + [other]
        else:
            remember_activation &amp;= other.remember_activation
            stack_activation &amp;= other.stack_activation
            rules = list(set(self.rules + other.rules))
        return self.__class__(rules, remember_activation=remember_activation, stack_activation=stack_activation)

    def __len__(self):
        return len(self.rules)

    def __eq__(self, other: &#34;RuleSet&#34;):
        return set(self.rules) == set(other.rules)

    def __iter__(self):
        if hasattr(self, &#34;_rules&#34;):
            return self.rules.__iter__()
        else:
            return [].__iter__()

    def __getitem__(self, key):
        if isinstance(key, slice):
            indices = range(*key.indices(len(self.rules)))
            return self.__class__([self.rules[i] for i in indices])
        return self.rules.__getitem__(key)

    def __str__(self):
        if len(self) &lt; 2 * RuleSet.NLINES:
            return &#34;\n&#34;.join([str(self[i]) for i in range(len(self))])
        else:
            return &#34;\n&#34;.join(
                [str(self[i]) for i in range(RuleSet.NLINES)]
                + [&#34;...&#34;]
                + [str(self[i]) for i in range(len(self) - RuleSet.NLINES, len(self))]
            )

    @property
    def to_hash(self):
        if len(self) == 0:
            return &#34;rs&#34;,
        to_hash = (&#34;rs&#34;,)
        for r in self:
            rule_hash = r.to_hash[1:]
            to_hash += rule_hash
        return to_hash

    # noinspection PyProtectedMember
    def __hash__(self) -&gt; hash:
        return hash(frozenset(self.to_hash))

    # noinspection PyProtectedMember,PyTypeChecker
    def _update_activation(self, other: Union[Rule, &#34;RuleSet&#34;]):
        if other.activation_available:
            if self._activation is None:
                self._activation = Activation(other.activation, to_file=Rule.LOCAL_ACTIVATION)
            else:
                self._activation = self._activation | other._activation

    # noinspection PyProtectedMember,PyTypeChecker
    def _update_stacked_activation(self, other: Union[Rule, &#34;RuleSet&#34;]):
        if other.activation_available:
            if self._activation is None:
                if isinstance(other, Rule):
                    self.stacked_activations = pd.DataFrame(data=np.array(other.activation).T, columns=[str(other)])
                else:
                    self.stacked_activations = other.stacked_activations
            else:
                if isinstance(other, Rule):
                    self.stacked_activations[str(other)] = other.activation
                else:
                    self.stacked_activations = pd.concat([self.stacked_activations, other.stacked_activations], axis=1)

    def compute_self_activation(self):
        if len(self) == 0:
            return
        activations_available = all([r.activation_available for r in self])
        if activations_available:
            # noinspection PyProtectedMember
            self._activation = Activation.multi_logical_or([r._activation for r in self])

    def compute_stacked_activation(self):
        if len(self) == 0:
            return
        activations_available = all([r.activation_available for r in self])
        if activations_available:
            # noinspection PyProtectedMember
            self.stacked_activations = pd.DataFrame(
                data=np.array([r.activation for r in self]).T, columns=[str(r.condition) for r in self]
            )

    # def __del__(self):
    #     self.del_activations()
    #     self.del_activation()

    def del_activations(self):
        for r in self:
            r.del_activation()

    def del_activation(self):
        &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
        available&#34;&#34;&#34;
        if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
            self._activation.delete()

    def del_stacked_activations(self):
        if hasattr(self, &#34;stacked_activations&#34;) and self.stacked_activations is not None:
            del self.stacked_activations
            self.stacked_activations = None

    def append(self, rule: Rule, update_activation: bool = True):
        if not isinstance(rule, Rule):
            raise TypeError(f&#34;RuleSet&#39;s append method expects a Rule object, got {type(rule)}&#34;)
        remember_activation = self.remember_activation
        stack_activation = self.stack_activation
        if not update_activation:
            self.remember_activation = False
            self.stack_activation = False
        self.__iadd__(rule)
        self.remember_activation = remember_activation
        self.stack_activation = stack_activation

    def sort(self, criterion: str = None, reverse: bool = False) -&gt; None:
        if len(self) == 0:
            return
        import ast

        if criterion is None or criterion == &#34;&#34;:
            if not (
                hasattr(self[0].condition, &#34;features_names&#34;)
                and hasattr(self[0].condition, &#34;bmins&#34;)
                and hasattr(self[0].condition, &#34;bmaxs&#34;)
            ):
                return
            # noinspection PyUnresolvedReferences
            fnames = list(set([str(r.features_names) for r in self]))
            dict_names = {}
            lmax = 1
            for f in fnames:
                l_ = len(ast.literal_eval(f))
                if l_ &gt; lmax:
                    lmax = l_
                if l_ not in dict_names:
                    dict_names[l_] = []
                dict_names[l_].append(f)
            for l_ in dict_names:
                dict_names[l_].sort(reverse=reverse)
            fnames = []
            for l_ in range(1, lmax + 1):
                if l_ in dict_names:
                    fnames += dict_names[l_]

            rules_by_fnames = OrderedDict({f: [] for f in fnames})
            for rule in self:
                # noinspection PyUnresolvedReferences
                v = str(rule.features_names)
                rules_by_fnames[v].append(rule)
            rules_by_fnames = {
                n: sorted(rules_by_fnames[n], key=lambda x: x.condition.bmins + x.condition.bmaxs)
                for n in rules_by_fnames
            }
            self._rules = []
            for n in rules_by_fnames:
                self._rules += rules_by_fnames[n]
        elif hasattr(self[0], criterion):
            self._rules = sorted(self, key=lambda x: getattr(x, criterion), reverse=reverse)
        else:
            raise ValueError(f&#34;Can not sort RuleSet according to criterion {criterion}&#34;)
        if self.stack_activation:
            self.stacked_activations = self.stacked_activations[[str(r.condition) for r in self]]

    @property
    def activation_available(self):
        if self._activation is None:
            return False
        if self._activation.data_format == &#34;file&#34;:
            return self._activation.data.is_file()
        else:
            return self._activation.data is not None

    @property
    def stacked_activations_available(self):
        if self.stack_activation is None:
            return False
        return True

    @property
    def activation(self) -&gt; Union[None, np.ndarray]:
        &#34;&#34;&#34;Decompress activation vector

        Returns
        -------
        np.ndarray
            of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
        &#34;&#34;&#34;
        if self._activation:
            return self._activation.raw
        return None

    @property
    def rules(self) -&gt; List[Rule]:
        return self._rules

    def calc_activation(self, xs: np.ndarray):
        if len(self) == 0:
            raise ValueError(&#34;Can not use calc_activation : The ruleset is empty!&#34;)
        [rule.calc_activation(xs) for rule in self.rules]
        self._activation = None
        self.compute_self_activation()

    def calc_stacked_activations(self, xs: np.ndarray):
        if len(self) == 0:
            raise ValueError(&#34;Can not use calc_stacked_activations : The ruleset is empty!&#34;)
        [rule.calc_activation(xs) for rule in self.rules]
        self._activation = None
        self.compute_stacked_activation()

    @property
    def coverage(self) -&gt; float:
        if not self.activation_available:
            return 0.0
        else:
            return self._activation.coverage

    def get_variables_count(self):
        &#34;&#34;&#34;
        Get a counter of all different features in the ruleset
        Parameters
        ----------
        Return
        ------
        count : {Counter type}
            Counter of all different features in the ruleset
        &#34;&#34;&#34;
        # noinspection PyUnresolvedReferences
        var_in = [
            rule.condition.features_names
            if isinstance(rule.condition, HyperrectangleCondition)
            else rule.condition.features_indexes
            for rule in self
        ]
        if len(var_in) &gt; 1:
            var_in = reduce(operator.add, var_in)
        count = Counter(var_in)

        count = count.most_common()
        return count</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ruleskit.ruleset.RuleSet.NLINES"><code class="name">var <span class="ident">NLINES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ruleskit.ruleset.RuleSet.activation"><code class="name">var <span class="ident">activation</span> : Union[NoneType, numpy.ndarray]</code></dt>
<dd>
<div class="desc"><p>Decompress activation vector</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation(self) -&gt; Union[None, np.ndarray]:
    &#34;&#34;&#34;Decompress activation vector

    Returns
    -------
    np.ndarray
        of the form [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1]
    &#34;&#34;&#34;
    if self._activation:
        return self._activation.raw
    return None</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.activation_available"><code class="name">var <span class="ident">activation_available</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def activation_available(self):
    if self._activation is None:
        return False
    if self._activation.data_format == &#34;file&#34;:
        return self._activation.data.is_file()
    else:
        return self._activation.data is not None</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.coverage"><code class="name">var <span class="ident">coverage</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coverage(self) -&gt; float:
    if not self.activation_available:
        return 0.0
    else:
        return self._activation.coverage</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.rules"><code class="name">var <span class="ident">rules</span> : List[<a title="ruleskit.rule.Rule" href="rule.html#ruleskit.rule.Rule">Rule</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rules(self) -&gt; List[Rule]:
    return self._rules</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.stacked_activations_available"><code class="name">var <span class="ident">stacked_activations_available</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stacked_activations_available(self):
    if self.stack_activation is None:
        return False
    return True</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.to_hash"><code class="name">var <span class="ident">to_hash</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_hash(self):
    if len(self) == 0:
        return &#34;rs&#34;,
    to_hash = (&#34;rs&#34;,)
    for r in self:
        rule_hash = r.to_hash[1:]
        to_hash += rule_hash
    return to_hash</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ruleskit.ruleset.RuleSet.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, rule: <a title="ruleskit.rule.Rule" href="rule.html#ruleskit.rule.Rule">Rule</a>, update_activation: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, rule: Rule, update_activation: bool = True):
    if not isinstance(rule, Rule):
        raise TypeError(f&#34;RuleSet&#39;s append method expects a Rule object, got {type(rule)}&#34;)
    remember_activation = self.remember_activation
    stack_activation = self.stack_activation
    if not update_activation:
        self.remember_activation = False
        self.stack_activation = False
    self.__iadd__(rule)
    self.remember_activation = remember_activation
    self.stack_activation = stack_activation</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.calc_activation"><code class="name flex">
<span>def <span class="ident">calc_activation</span></span>(<span>self, xs: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_activation(self, xs: np.ndarray):
    if len(self) == 0:
        raise ValueError(&#34;Can not use calc_activation : The ruleset is empty!&#34;)
    [rule.calc_activation(xs) for rule in self.rules]
    self._activation = None
    self.compute_self_activation()</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.calc_stacked_activations"><code class="name flex">
<span>def <span class="ident">calc_stacked_activations</span></span>(<span>self, xs: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_stacked_activations(self, xs: np.ndarray):
    if len(self) == 0:
        raise ValueError(&#34;Can not use calc_stacked_activations : The ruleset is empty!&#34;)
    [rule.calc_activation(xs) for rule in self.rules]
    self._activation = None
    self.compute_stacked_activation()</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.compute_self_activation"><code class="name flex">
<span>def <span class="ident">compute_self_activation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_self_activation(self):
    if len(self) == 0:
        return
    activations_available = all([r.activation_available for r in self])
    if activations_available:
        # noinspection PyProtectedMember
        self._activation = Activation.multi_logical_or([r._activation for r in self])</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.compute_stacked_activation"><code class="name flex">
<span>def <span class="ident">compute_stacked_activation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_stacked_activation(self):
    if len(self) == 0:
        return
    activations_available = all([r.activation_available for r in self])
    if activations_available:
        # noinspection PyProtectedMember
        self.stacked_activations = pd.DataFrame(
            data=np.array([r.activation for r in self]).T, columns=[str(r.condition) for r in self]
        )</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.del_activation"><code class="name flex">
<span>def <span class="ident">del_activation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the activation vector's data, but not the object itself, so any computed attribute will remain
available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_activation(self):
    &#34;&#34;&#34;Deletes the activation vector&#39;s data, but not the object itself, so any computed attribute will remain
    available&#34;&#34;&#34;
    if hasattr(self, &#34;_activation&#34;) and self._activation is not None:
        self._activation.delete()</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.del_activations"><code class="name flex">
<span>def <span class="ident">del_activations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_activations(self):
    for r in self:
        r.del_activation()</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.del_stacked_activations"><code class="name flex">
<span>def <span class="ident">del_stacked_activations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def del_stacked_activations(self):
    if hasattr(self, &#34;stacked_activations&#34;) and self.stacked_activations is not None:
        del self.stacked_activations
        self.stacked_activations = None</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.get_variables_count"><code class="name flex">
<span>def <span class="ident">get_variables_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a counter of all different features in the ruleset
Parameters</p>
<hr>
<h2 id="return">Return</h2>
<p>count : {Counter type}
Counter of all different features in the ruleset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variables_count(self):
    &#34;&#34;&#34;
    Get a counter of all different features in the ruleset
    Parameters
    ----------
    Return
    ------
    count : {Counter type}
        Counter of all different features in the ruleset
    &#34;&#34;&#34;
    # noinspection PyUnresolvedReferences
    var_in = [
        rule.condition.features_names
        if isinstance(rule.condition, HyperrectangleCondition)
        else rule.condition.features_indexes
        for rule in self
    ]
    if len(var_in) &gt; 1:
        var_in = reduce(operator.add, var_in)
    count = Counter(var_in)

    count = count.most_common()
    return count</code></pre>
</details>
</dd>
<dt id="ruleskit.ruleset.RuleSet.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, criterion: str = None, reverse: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, criterion: str = None, reverse: bool = False) -&gt; None:
    if len(self) == 0:
        return
    import ast

    if criterion is None or criterion == &#34;&#34;:
        if not (
            hasattr(self[0].condition, &#34;features_names&#34;)
            and hasattr(self[0].condition, &#34;bmins&#34;)
            and hasattr(self[0].condition, &#34;bmaxs&#34;)
        ):
            return
        # noinspection PyUnresolvedReferences
        fnames = list(set([str(r.features_names) for r in self]))
        dict_names = {}
        lmax = 1
        for f in fnames:
            l_ = len(ast.literal_eval(f))
            if l_ &gt; lmax:
                lmax = l_
            if l_ not in dict_names:
                dict_names[l_] = []
            dict_names[l_].append(f)
        for l_ in dict_names:
            dict_names[l_].sort(reverse=reverse)
        fnames = []
        for l_ in range(1, lmax + 1):
            if l_ in dict_names:
                fnames += dict_names[l_]

        rules_by_fnames = OrderedDict({f: [] for f in fnames})
        for rule in self:
            # noinspection PyUnresolvedReferences
            v = str(rule.features_names)
            rules_by_fnames[v].append(rule)
        rules_by_fnames = {
            n: sorted(rules_by_fnames[n], key=lambda x: x.condition.bmins + x.condition.bmaxs)
            for n in rules_by_fnames
        }
        self._rules = []
        for n in rules_by_fnames:
            self._rules += rules_by_fnames[n]
    elif hasattr(self[0], criterion):
        self._rules = sorted(self, key=lambda x: getattr(x, criterion), reverse=reverse)
    else:
        raise ValueError(f&#34;Can not sort RuleSet according to criterion {criterion}&#34;)
    if self.stack_activation:
        self.stacked_activations = self.stacked_activations[[str(r.condition) for r in self]]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ruleskit" href="index.html">ruleskit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ruleskit.ruleset.RuleSet" href="#ruleskit.ruleset.RuleSet">RuleSet</a></code></h4>
<ul class="">
<li><code><a title="ruleskit.ruleset.RuleSet.NLINES" href="#ruleskit.ruleset.RuleSet.NLINES">NLINES</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.activation" href="#ruleskit.ruleset.RuleSet.activation">activation</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.activation_available" href="#ruleskit.ruleset.RuleSet.activation_available">activation_available</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.append" href="#ruleskit.ruleset.RuleSet.append">append</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.calc_activation" href="#ruleskit.ruleset.RuleSet.calc_activation">calc_activation</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.calc_stacked_activations" href="#ruleskit.ruleset.RuleSet.calc_stacked_activations">calc_stacked_activations</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.compute_self_activation" href="#ruleskit.ruleset.RuleSet.compute_self_activation">compute_self_activation</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.compute_stacked_activation" href="#ruleskit.ruleset.RuleSet.compute_stacked_activation">compute_stacked_activation</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.coverage" href="#ruleskit.ruleset.RuleSet.coverage">coverage</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.del_activation" href="#ruleskit.ruleset.RuleSet.del_activation">del_activation</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.del_activations" href="#ruleskit.ruleset.RuleSet.del_activations">del_activations</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.del_stacked_activations" href="#ruleskit.ruleset.RuleSet.del_stacked_activations">del_stacked_activations</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.get_variables_count" href="#ruleskit.ruleset.RuleSet.get_variables_count">get_variables_count</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.rules" href="#ruleskit.ruleset.RuleSet.rules">rules</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.sort" href="#ruleskit.ruleset.RuleSet.sort">sort</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.stacked_activations_available" href="#ruleskit.ruleset.RuleSet.stacked_activations_available">stacked_activations_available</a></code></li>
<li><code><a title="ruleskit.ruleset.RuleSet.to_hash" href="#ruleskit.ruleset.RuleSet.to_hash">to_hash</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>